<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小七快跑</title>
  
  <subtitle>沈小祺技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://luckyjq.github.io/"/>
  <updated>2019-07-31T05:46:43.681Z</updated>
  <id>https://luckyjq.github.io/</id>
  
  <author>
    <name>LuckyQ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【译】JavaScript作用域链中的标识符解析和闭包</title>
    <link href="https://luckyjq.github.io/2019/07/30/JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%AD%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6%E8%A7%A3%E6%9E%90%E5%92%8C%E9%97%AD%E5%8C%85/"/>
    <id>https://luckyjq.github.io/2019/07/30/JavaScript作用域链中的标识符解析和闭包/</id>
    <published>2019-07-29T16:00:00.000Z</published>
    <updated>2019-07-31T05:46:43.681Z</updated>
    
    <content type="html"><![CDATA[<p>这篇翻译紧接上一篇，建议先阅读<a href="https://blog.luckyq.cn/2019/07/29/javascript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%A0%86%E6%A0%88%E6%98%AF%E4%BB%80%E4%B9%88/" target="_blank" rel="noopener">JavaScript作用域链中的标识符解析和闭包</a>。</p><a id="more"></a><p>从我之前的文章中，我们知道每个函数调用时都有一个关联的执行上下文，其中包含一个变量对象[VO]，它由给定函数内部定义的所有变量，函数和参数组成。</p><p><strong>每个执行上下文的作用域链属性只是当前上下文的[VO] +所有父级的[VO]的集合</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scope = VO + All Parent VOs</span><br><span class="line">Eg: scopeChain = [ [VO] + [VO1] + [VO2] + [VO n+<span class="number">1</span>] ];</span><br></pre></td></tr></table></figure><h2 id="确定作用域链中的变量对象-VO"><a href="#确定作用域链中的变量对象-VO" class="headerlink" title="确定作用域链中的变量对象[VO]"></a>确定作用域链中的变量对象[VO]</h2><p>我们现在知道作用域链的第一个[VO]属于当前执行上下文，我们可以通过查看他的父上下文的作用域链来找到剩余的父[VO]：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">one</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    two();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        three();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">three</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">'I am at function three'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">one();</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/98ab0bff999457c76007c7a39c9ae635.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这个例子很简单，从全局上下文开始，我们调用one（），one（）调用two（），然后调用three（），three函数弹出一个alert。上面的图像显示了执行上下文堆栈的情况。我们可以看到此时的three作用域链如下所示：<br><strong>three() Scope Chain = [ [three() VO] + [two() VO] + [one() VO] + [Global VO] ];</strong></p><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>要注意的JavaScript的一个重要特性是，解释器使用词法作用域，而不是动态作用域。对所有内部函数来说，他们静态的绑定到父上下文中，即他们在代码中被定义的地方（个人理解为javascript的函数作用域在函数定义时确定，而非调用时）。</p><p>在上面的上一个例子中，three将始终静态绑定到two，而two依次绑定到one，依此类推。这给出了链接效果，其中所有内部函数都可以通过静态绑定的作用域链访问外部函数VO。</p><p>这个词法作用域是许多开发人员混淆的根源。我们知道每次调用函数都会创建一个新的执行上下文和相关的VO，它保存在当前上下文中计算的变量值。</p><p>正是这种对VO的动态的，运行时的评估以及每个上下文的词法作用域，导致程序行为出现意外结果。采用以下经典示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myAlerts = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    myAlerts.push(</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(i)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myAlerts[<span class="number">0</span>](); <span class="comment">// 5</span></span><br><span class="line">myAlerts[<span class="number">1</span>](); <span class="comment">// 5</span></span><br><span class="line">myAlerts[<span class="number">2</span>](); <span class="comment">// 5</span></span><br><span class="line">myAlerts[<span class="number">3</span>](); <span class="comment">// 5</span></span><br><span class="line">myAlerts[<span class="number">4</span>](); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>乍一看，那些刚接触JavaScript的人会认为alert弹出的i是定义函数的每个增量的i的值，所以aleert将分别警告1,2,3,4和5。</p><p>这是最常见的混淆点。函数inner是在全局上下文中创建的，因此其作用域链静态地绑定到全局上下文。</p><p>第11~15行调用inner（），它将在inner.ScopeChain中查找解析i，而inner函数定义在全局上下文中。当for循环结束时，i已经增加到5，每次调用inner时都会得到相同的结果。静态绑定的作用域链，含有来自包含实时变量的每个上下文的[VOs]，通常会让开发人员感到意外。</p><h2 id="确定变量的值"><a href="#确定变量的值" class="headerlink" title="确定变量的值"></a>确定变量的值</h2><p>以下示例alert变量a，b和c的和，它给出了6的结果。</p><p>第14行很有趣，乍一看似乎a和b不在函数three内，所以这段代码怎么还能运行？要理解解释器如何评估此代码，我们需要在执行第14行时查看函数three的作用域链：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/7044601baa80d2ee950076dc17b1cb76.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>当解释器执行第14行：alert（a + b + c）时，它通过查看作用域链并检查第一个变量对象，即[three( ) VO]。它会检查[three( ) VO]中是否存在a，但是找不到具有该名称的任何属性，因此继续检查下一个[VO]。</p><p>解释器按顺序检查每个[VO]是否存在变量名，如果存在值将返回到原始计算代码，否则程序将抛出ReferenceError。因此，给定上面的示例，您可以看到在函数three的作用域链中，a，b和c都是可解析的。</p><h2 id="闭包是怎么工作的"><a href="#闭包是怎么工作的" class="headerlink" title="闭包是怎么工作的"></a>闭包是怎么工作的</h2><p>在JavaScript中，闭包通常被认为是某种魔法，只有高级开发人员才能真正理解，但事实上，它只是对作用域链的简单理解。正如<strong>Douglas Crockford</strong>所说，闭包只是：</p><blockquote><p>An inner function always has access to the vars and parameters of its outer function, even after the outer function has returned…</p></blockquote><blockquote><p>内部函数始终能够访问外部函数的变量和参数，即使外部函数已经被返回</p></blockquote><p>下面的代码是一个闭包的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">'private variable'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> callAlert = foo();</span><br><span class="line"></span><br><span class="line">callAlert(); <span class="comment">// private variable</span></span><br></pre></td></tr></table></figure><p>全局上下文有一个名为foo的函数和一个名为callAlert的变量，它保存foo( )返回的值。开发人员常常感到惊讶和困惑的是，即使在foo完成执行后，foo的私有变量a仍然可以被callAlert访问。</p><p>如果我们详细查看每个上下文，我们将看到以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Global Context when evaluated</span></span><br><span class="line">global.VO = &#123;</span><br><span class="line">    foo: pointer to foo(),</span><br><span class="line">    callAlert: returned value <span class="keyword">of</span> global.VO.foo</span><br><span class="line">    scopeChain: [global.VO]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Foo Context when evaluated</span></span><br><span class="line">foo.VO = &#123;</span><br><span class="line">    bar: pointer to bar(),</span><br><span class="line">    a: <span class="string">'private variable'</span>,</span><br><span class="line">    scopeChain: [foo.VO, global.VO]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bar Context when evaluated</span></span><br><span class="line">bar.VO = &#123;</span><br><span class="line">    scopeChain: [bar.VO, foo.VO, global.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以通过调用callAlert来看到，我们得到函数foo( )返回值，它返回指向bar函数的指针。在执行bar函数时，bar.VO.scopeChain是[bar.VO，foo.VO，global.VO]。</p><p>alert(a)，解释器检查bar.VO.scopeChain中的第一个VO，查找名为a的属性但找不到匹配项，因此立即转到下一个VO，foo.VO。</p><p>它检查属性的存在，这次找到一个匹配，将值返回到bar上下文，这解释了为什么即使foo已经完成执行，还是能访问’私有变量’a。</p><p>到此为止，我们已经涵盖了作用域链及其词法作用域的细节，以及闭包和变量解析是如何工作。本文的其余部分将讨论与上述内容相关的一些有趣情况。</p><h2 id="原型链是如何影响变量的？"><a href="#原型链是如何影响变量的？" class="headerlink" title="原型链是如何影响变量的？"></a>原型链是如何影响变量的？</h2><p>JavaScript本质上是基于原型链的，除了null和undefined之外，语言中的几乎所有内容都是对象。当试图访问对象上的属性时，解释器将尝试通过查找对象中的属性。如果它找不到属性，它将继续查找原型链，这是一个继承的对象链，直到它找到属性，或遍历到链的末尾。</p><p>这导致了一个有趣的问题，解释器是先使用作用链还是原型链解析对象属性？两者都会使用。尝试解析属性或标识符时，将首先使用作用链来寻找对象。找到对象后，将遍历该对象的原型链，查找属性名称。我们来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    bar.a = <span class="string">'Set from foo()'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(bar.a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()(); <span class="comment">// 'Set from foo()'</span></span><br></pre></td></tr></table></figure><p>第5行在全局对象bar上创建属性a，并将其值设置为‘Set from foo()’。解释器查找作用域链，并按预期在全局上下文中查找bar.a。现在，让我们考虑以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.prototype.a = <span class="string">'Set from prototype'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(bar.a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()(); <span class="comment">// 'Set from prototype()'</span></span><br></pre></td></tr></table></figure><p>在运行时，我们调用inner函数，它试图通过在其作用域链中查找bar的存在来解析bar.a。它在全局上下文中找到bar，并进入搜索bar以查找名为a的属性。但是，a从未在bar上设置，因此解释器遍历bar对象的原型链并发现在Object.prototype上设置了一个。</p><p>这种行为解释了标识符的解析：在作用链中找到对象，然后继续向上找对象的原型链，直到找到属性，或返回undefined。</p><h2 id="什么时候使用闭包"><a href="#什么时候使用闭包" class="headerlink" title="什么时候使用闭包"></a>什么时候使用闭包</h2><p>闭包是一个强大的JavaScript概念，使用它们的一些最常见的情况是：</p><p><strong>封装</strong><br>允许我们在暴露受控公共接口的同时，从外部作用域隐藏上下文的实现细节。这通常被称为模块模式或揭示模式。</p><p><strong>回调</strong><br>也许闭包最强大的用途之一就是回调。浏览器中的JavaScript通常在单线程事件循环中运行，阻止其他事件直到当前事件执行完成。回调允许我们以非阻塞方式推迟对函数的调用，通常是为了响应事件的完成。这方面的一个例子是在对服务器进行AJAX调用时，使用回调来处理响应，同时仍然保持创建它的绑定。</p><p><strong>闭包作为参数</strong><br>我们还可以将闭包作为参数传递给函数，这是一个强大的函数范例，用于为复杂代码创建更优雅的解决方案。以最小排序函数为例，通过将闭包作为参数传递，我们可以为不同类型的数据排序定义实现，同时仍然重用单个函数体作为原理图。</p><h2 id="什么时候不使用闭包"><a href="#什么时候不使用闭包" class="headerlink" title="什么时候不使用闭包"></a>什么时候不使用闭包</h2><p>虽然闭包很强大，但由于某些性能问题，应该谨慎使用它们：</p><p><strong>长作用域链</strong><br>多个嵌套函数是您可能遇到某些性能问题的典型信号。请记住，每次需要确定变量值时，必须遍历作用链以查找标识符，因此不言而喻，作用域链越长，查找时间越长。</p><p><strong>垃圾收集</strong><br>JavaScript是一种自带垃圾收集的语言，这意味着与低级编程语言不同，开发人员通常不必担心内存管理。但是，这种自动垃圾收集通常会导致开发人员应用程序遭受性能不佳和内存泄漏的困扰。</p><p>不同的JavaScript引擎实现垃圾收集略有不同，因为ECMAScript没有定义应该如何处理实现，但是当尝试创建高性能，无泄漏的JavaScript代码时，相同的理念可以应用于引擎。一般来说，当对象无法被程序中运行的任何其他活动对象引用或无法访问时，垃圾收集器将尝试释放该对象的内存。</p><p><strong>循环引用</strong><br>不太喜欢原文的内容，后续找个好的例子</p><h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p>传送：<a href="http://davidshariff.com/blog/javascript-scope-chain-and-closures/" target="_blank" rel="noopener">http://davidshariff.com/blog/javascript-scope-chain-and-closures/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇翻译紧接上一篇，建议先阅读&lt;a href=&quot;https://blog.luckyq.cn/2019/07/29/javascript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%A0%86%E6%A0%88%E6%98%AF%E4%BB%80%E4%B9%88/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript作用域链中的标识符解析和闭包&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://luckyjq.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://luckyjq.github.io/tags/js/"/>
    
      <category term="基础" scheme="https://luckyjq.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="翻译" scheme="https://luckyjq.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【译】JavaScript执行上下文和执行上下文堆栈是什么</title>
    <link href="https://luckyjq.github.io/2019/07/29/javascript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%A0%86%E6%A0%88%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://luckyjq.github.io/2019/07/29/javascript执行上下文和堆栈是什么/</id>
    <published>2019-07-28T16:00:00.000Z</published>
    <updated>2019-07-29T08:16:57.816Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中，我将深入探讨JavaScript的一个最基本的部分，即执行上下文。在本文结束时，您应该更清楚地了解js解释器尝试做什么，为什么某些函数/变量可以在他们声明前使用，以及它们的值是如何确定的。</p><a id="more"></a><h2 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h2><p>当js代码运行时，它的执行环境非常重要，并且为以下之一：</p><ol><li>全局代码：首次执行代码的默认环境。</li><li>函数代码 - 每当执行流程进入函数体时。</li><li>Eval代码 - 要在内部eval函数内执行的文本。</li></ol><p>你可能在网上读了很多文章关于作用域，这篇文章的目的是让你更容易的理解他们。让我们将执行上下文视为当前正在运行代码的环境/作用域。现在我们来看一个简单的例子，包含全局和函数（局部）环境下运行代码。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/87794fd6938766f02a3bc07b3766ab9a.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这里没有什么特别之处，我们有一个由紫色边框表示的全局上下文和由绿色，蓝色和橙色边框表示的3个不同的函数上下文。只能有1个全局上下文，并且它可以被程序中的任何其他上下文访问。</p><p>您可以拥有任意数量的函数上下文，并且每个函数调用都会创建一个新的上下文，从而创建一个私有作用域，在函数内部声明的任何内容都无法从当前函数作用域外直接访问。在上面的示例中，函数可以访问在其当前上下文之外声明的变量（全局上下文中的变量），但外部上下文无法访问person函数中的变量/函数。为什么会这样？这段代码究竟是如何评估的？</p><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>浏览器中的JavaScript解释器实现为单线程。这实际上意味着在浏览器中一次只能发生一件事，其他动作或事件在所谓的执行堆栈中排队。下图是单线程堆栈的抽象视图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/0bae0c84555b29ea029222e6bc6b909f.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>我们已经知道，当浏览器首次加载脚本时，它默认进入全局执行上下文。如果在全局代码中调用一个函数，程序的顺序流进入被调用的函数，创建一个新的执行上下文并将该上下文推送到执行堆栈的顶部。</p><p>如果在当前函数中调用另一个函数，则会发生同样的事情。代码的执行流程进入内部函数，该函数创建一个新的执行上下文，该上下文被推送到现有堆栈的顶部。浏览器将始终执行位于堆栈顶部的当前执行上下文，并且一旦函数完成执行当前执行上下文，它将从堆栈顶部弹出，将控制权返回到当前堆栈中的下一个z上下文。下面的示例显示了递归函数和程序的执行堆栈：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://davidshariff.com/blog/wp-content/uploads/2012/06/es1.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><p>代码只调用自身3次，将i的值递增1.每次调用函数foo时，都会创建一个新的执行上下文。一旦上下文完成执行，它就会弹出堆栈并且控制返回到它下面的上下文，直到再次达到全局上下文。</p><p><strong>有五个关键点可以帮助你记忆执行上下文</strong></p><ol><li>单线程</li><li>同步执行代码</li><li>一个全局环境</li><li>可以有很多个函数环境</li><li>每个函数调用都会创建一个新的执行上下文，对自身的调用也是</li></ol><h2 id="执行上下文的细节"><a href="#执行上下文的细节" class="headerlink" title="执行上下文的细节"></a>执行上下文的细节</h2><p>现在我们知道每次调用一个函数时，都会创建一个新的执行上下文。但是，在JavaScript解释器中，对执行上下文的每次调用都有两个阶段：</p><ol><li><p><strong>创建（准备）阶段</strong>（函数被调用，但是函数内部代码还未执行）</p><ul><li>创建范围链</li><li>创建变量，函数和函数参数</li><li>确定“this”的值</li></ul></li><li><p><strong>激活/代码执行阶段</strong>（分配值，引用函数，解释/执行代码</p></li></ol><p>我们可以将每个执行上下文在概念上表示为具有3个属性的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">executionContextObj = &#123;</span><br><span class="line">    <span class="string">'scopeChain'</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">'variableObject'</span>: &#123;</span><br><span class="line">        <span class="comment">// 函数的参数/传入的参数</span></span><br><span class="line">        <span class="comment">// 内部函数</span></span><br><span class="line">        <span class="comment">// 内部变量</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'this'</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量对象-VO-激活对象-AO"><a href="#变量对象-VO-激活对象-AO" class="headerlink" title="变量对象[VO] / 激活对象[AO]"></a>变量对象[VO] / 激活对象[AO]</h2><p>executionContextObj在函数调用时创建，但是在函数代码被执行之前。这就是我们之前说的第1阶段，即准备阶段。在这阶段，解释器通过扫描传入的参数或函数的参数，本地函数声明，局部变量声明来创建executionContextObj。此扫描的结果将成为executionContextObj中的variableObject。</p><p><strong>以下是解释器如何评估代码的伪概述：</strong></p><ol><li><strong>发现某些代码调用了一个函数</strong></li><li><strong>在执行这个函数的代码前，创建了这个函数的执行上下文（execution context）</strong></li><li><strong>进入执行的第一阶段，准备阶段</strong><ul><li>初始化作用域链（scope chain）</li><li>创建名为arguments的对象。检查调用函数的参数，初始化参数名字和值<strong>（个人理解为把调用函数的实参复制一份放到VO中，都说js函数是值传递大概和这里关系很密切）</strong></li><li>扫描函数内容寻找函数定义<ul><li>对于找到的每个函数，在变量对象中创建一个属性，该属性是确切的函数名称，该属性具有指向内存中函数的引用指针</li><li>如果函数名已存在，则将覆盖引用指针值</li></ul></li><li>扫描函数寻找变量定义<ul><li>对于找到的每个变量声明，在变量对象中创建一个属性，该属性是变量名称，并将值初始化为undefined</li><li>如果变量名称已存在于变量对象中，则不执行任何操作并继续扫描</li></ul></li><li>确定上下文中“this”的值</li></ul></li><li><strong>激活对象 / 代码执行阶段</strong><br>执行函数代码，并在代码逐行执行时分配变量值</li></ol><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">'hello'</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> <span class="title">privateB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">22</span>)</span><br></pre></td></tr></table></figure><p>当执行foo(22)调用函数时，该函数的执行上下文在准备阶段应该是下面这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fooExecutionContext = &#123;</span><br><span class="line">    scopeChain: &#123; ... &#125;,</span><br><span class="line">    variableObject: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            <span class="number">0</span>: <span class="number">22</span>,</span><br><span class="line">            length: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        i: <span class="number">22</span>,</span><br><span class="line">        c: pointer to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        <span class="title">a</span>: <span class="title">undefined</span>,</span></span><br><span class="line"><span class="function">        <span class="title">b</span>: <span class="title">undefined</span></span></span><br><span class="line"><span class="function">    &#125;,</span></span><br><span class="line"><span class="function">    <span class="title">this</span>: </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，创建阶段处理定义属性的名称，而不是为它们赋值，但正式参数（实参）除外。创建阶段完成后，执行流程进入函数内，激活/代码执行阶段在函数执行完毕后如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fooExecutionContext = &#123;</span><br><span class="line">    scopeChain: &#123; ... &#125;,</span><br><span class="line">    variableObject: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            <span class="number">0</span>: <span class="number">22</span>,</span><br><span class="line">            length: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        i: <span class="number">22</span>,</span><br><span class="line">        c: pointer to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        <span class="title">a</span>: <span class="title">undefined</span>,</span></span><br><span class="line"><span class="function">        <span class="title">b</span>: <span class="title">undefined</span></span></span><br><span class="line"><span class="function">    &#125;,</span></span><br><span class="line"><span class="function">    <span class="title">this</span>: </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于变量提升"><a href="#关于变量提升" class="headerlink" title="关于变量提升"></a>关于变量提升</h2><p>在掌握了关于js解释器如何创建激活对象的知识后，我们很容易解释变量，函数提升是怎么一回事。使用以下代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo); <span class="comment">// function pointer</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> foo = <span class="string">'hello'</span>,</span><br><span class="line">    bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'world'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>​<strong>为什么我们可以在声明foo之前访问他</strong><br>​这段代码是立即执行函数，执行时创建相应执行上下文。在执行代码前即准备阶段，进行参数扫描，函数扫描，变量扫描，此时foo函数已经出现在VO中，所以可以访问。<br>​​<br>​<strong>Foo被声明两次，为什么foo显示为函数而不是未定义或字符串</strong><br>​接上一问，在准备阶段进行完函数扫描开始进行变量扫描，发现foo变量，但是此时VO内已经有同名的变量名，按照规则将略过。准备阶段完成，开始逐行执行代码并赋值，由于foo定义在console语句下面，所以还是输出VO中之前定义的foo，即函数。</p><p><strong>为什么bar的值是undefined</strong><br>接上一问，在准备阶段进行变量扫描时发现bar，VO中没有所以bar作为属性名，值为undefined。进入执行阶段bar赋值语句在console语句下面，所以还是输出undefined。</p><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p>传送：<a href="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/" target="_blank" rel="noopener">http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这篇文章中，我将深入探讨JavaScript的一个最基本的部分，即执行上下文。在本文结束时，您应该更清楚地了解js解释器尝试做什么，为什么某些函数/变量可以在他们声明前使用，以及它们的值是如何确定的。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://luckyjq.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://luckyjq.github.io/tags/js/"/>
    
      <category term="基础" scheme="https://luckyjq.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="翻译" scheme="https://luckyjq.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>个人小项目截图</title>
    <link href="https://luckyjq.github.io/2019/07/25/%E9%A1%B9%E7%9B%AE%E5%9B%BE/"/>
    <id>https://luckyjq.github.io/2019/07/25/项目图/</id>
    <published>2019-07-24T16:00:00.000Z</published>
    <updated>2019-07-25T13:40:17.959Z</updated>
    
    <content type="html"><![CDATA[<p>两个简单的小项目</p><a id="more"></a><h2 id="西电校淘小程序"><a href="#西电校淘小程序" class="headerlink" title="西电校淘小程序"></a>西电校淘小程序</h2><p>这个项目是在大三时候做的小程序项目，做的是校园二手平台<br>前端页面都是自己设计，用的原生的小程序组件<br>后端当时不怎么会，直接用的第三方的知晓云<br>这个小程序现在还在线上。。</p><img style="width:200px;" src="http://gitblog.luckyq.cn/027eda8474647fc2d0b59b5cf23494fb.jpg" alt="真棒" align="center"><h2 id="西电农贸小程序-管理后台"><a href="#西电农贸小程序-管理后台" class="headerlink" title="西电农贸小程序+管理后台"></a>西电农贸小程序+管理后台</h2><p>当时是一个导员推荐给学校一个专卖粮油的做小程序，想法就是前一天晚上可以预定，然后第二天他直接去送就可以了<br>页面很简单，当时学了点node，所以直接撸了一套全栈的，大概10天左右完成了，然后部署在自己的腾讯云服务器上了<br>不过当时没注意mongodb默认是空密码的，然后之前不懂腾讯云为了方便把所有端口都开了，晾凉了，数据库被清了<br>现在没部署在服务器上，不过有截图</p><p><strong>小程序</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/a00b421b7fb836b35486b496cdc1b8e6.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>h5客户端</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/1d7a5e2dacb7824b72eeaf254e76bcd5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>web后台</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/92fbbd6da857d8c28de9f06dc8d58bcc.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/4069adeb529b9e10cae289bafab3bb16.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/3d60c33a731909b751353a298f2b2612.png" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两个简单的小项目&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="https://luckyjq.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="koa2" scheme="https://luckyjq.github.io/tags/koa2/"/>
    
      <category term="vue" scheme="https://luckyjq.github.io/tags/vue/"/>
    
      <category term="小程序" scheme="https://luckyjq.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="项目" scheme="https://luckyjq.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>实现一个类似vue的双向绑定</title>
    <link href="https://luckyjq.github.io/2019/07/02/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BCvue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <id>https://luckyjq.github.io/2019/07/02/实现一个类似vue的双向绑定/</id>
    <published>2019-07-01T16:00:00.000Z</published>
    <updated>2019-07-03T04:14:02.919Z</updated>
    
    <content type="html"><![CDATA[<p>vue用了有段时间了，参考了github的文章，写了个简化版</p><a id="more"></a><p>github文章链接：<a href="https://github.com/DMQ/mvvm" target="_blank" rel="noopener">https://github.com/DMQ/mvvm</a><br>如果看不懂就看我的啊，嘿嘿嘿</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用Vue也有一段时间了，vue作为一个MVVM框架，最有名的就是双向绑定<br>一般来说当数据变化时，视图层跟着变化，这是单向的<br>当视图层变化时，数据也跟着变，这就是双向的<br>比如在vue中通过v-model绑定的输入框，当输入框内值变化时数据也跟着变化</p><p>今天就来实现一个类似于vue的双向绑定，预期效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视图层</span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    <span class="keyword">this</span> is &#123;&#123;name&#125;&#125;, &#123;&#123;age&#125;&#125; years old!</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">        &#123;&#123;name&#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据层</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> MVVM(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">'jianqi'</span>,</span><br><span class="line">        age: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Object-defineProperty的使用"><a href="#Object-defineProperty的使用" class="headerlink" title="Object.defineProperty的使用"></a>Object.defineProperty的使用</h2><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。<br>MDN:<a href="https://dwz.cn/umKlHoaq" target="_blank" rel="noopener">https://dwz.cn/umKlHoaq</a></p><p>定义对象descriptor时注意事项：</p><ol><li>属性描述（configurable，enumerable）：<br>通过这个定义的属性默认不可被删除（delete obj.xxx），默认不可遍历（for in）</li><li>值描述（value， writable）：<br>value和writable，value默认为undefined，writable默认为false值不能被改变</li><li>存取描述：get，set函数</li><li>值描述符和存取描述符不能同时存在</li></ol><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>Subject是一个主题（网站）。Observer相当于一个个的观察者（网民），他们可以订阅Subject，当Subject更新时通知Observer，触发Observer之前定义的回调。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//es6实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="number">0</span></span><br><span class="line">        <span class="keyword">this</span>.observers = []</span><br><span class="line">    &#125;</span><br><span class="line">    getState() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.state</span><br><span class="line">    &#125;</span><br><span class="line">    setState(state)&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state</span><br><span class="line">        <span class="keyword">this</span>.notifyAllObservers()</span><br><span class="line">    &#125;</span><br><span class="line">    notifyAllObservers()&#123;</span><br><span class="line">        <span class="keyword">this</span>.observers.forEach(<span class="function"><span class="params">observer</span>=&gt;</span>&#123;</span><br><span class="line">            observer.update()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    attach(observer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.observers.push(observer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, subject)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.subject = subject</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    update() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> update,state:<span class="subst">$&#123;<span class="keyword">this</span>.subject.getState()&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Subject()</span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> Observer(<span class="string">'o'</span>, s)</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="keyword">new</span> Observer(<span class="string">'o2'</span>, s)</span><br><span class="line">s.setState(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>通过使用Object.defineProperty（数据拦截）和观察者模式实现双向绑定<br>原理图：</p><ol><li>主题是什么？  一个个key，比如name</li><li>观察者是什么？  视图里面的，需要被替换成数据的地方</li><li>观察者什么时候订阅？<br>一开始执行MVVM初始化时候根据el遍历dom节点，发现时候时订阅对应主题xxxx</li><li>主题什么时候通知更新？<br>当xxxx改变时，通知观察者更新内容。可以在一开始就监控data通过Object.defineProperty()实现</li></ol><h2 id="实现单向数据流（数据-gt-视图）"><a href="#实现单向数据流（数据-gt-视图）" class="headerlink" title="实现单向数据流（数据=&gt;视图）"></a>实现单向数据流（数据=&gt;视图）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 总入口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MVVM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(opts)&#123;</span><br><span class="line">    <span class="comment">// 初始化，绑定数据到vm对象上</span></span><br><span class="line">        <span class="keyword">this</span>.init(opts)</span><br><span class="line">        <span class="comment">// 遍历所有data值，设置get和set方法</span></span><br><span class="line">        observe(<span class="keyword">this</span>.$data)</span><br><span class="line">        <span class="comment">// 遍历dom树，查找&#123;&#123;&#125;&#125;的特殊标记</span></span><br><span class="line">        <span class="keyword">this</span>.compile()</span><br><span class="line">    &#125;</span><br><span class="line">    init(opts)&#123;</span><br><span class="line">        <span class="keyword">this</span>.$el = <span class="built_in">document</span>.querySelector(opts.el)</span><br><span class="line">        <span class="keyword">this</span>.$data = opts.data</span><br><span class="line">    &#125;</span><br><span class="line">    compile()&#123;</span><br><span class="line">        <span class="keyword">this</span>.traverse(<span class="keyword">this</span>.$el)</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(node)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.nodeType === <span class="number">1</span>)&#123;</span><br><span class="line">            node.childNodes.forEach(<span class="function"><span class="params">childNode</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.traverse(childNode)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(node.nodeType === <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.renderText(node)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    renderText(node)&#123;</span><br><span class="line">        <span class="keyword">let</span> reg = <span class="regexp">/&#123;&#123;(.+?)&#125;&#125;/g</span></span><br><span class="line">        <span class="keyword">let</span> match</span><br><span class="line">        <span class="keyword">while</span> (match = reg.exec(node.nodeValue))&#123;</span><br><span class="line">            <span class="keyword">let</span> raw = match[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">let</span> key = match[<span class="number">1</span>].trim()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 初始化时绑定data里的数据到视图对应节点</span></span><br><span class="line">            node.nodeValue = node.nodeValue.replace(raw, <span class="keyword">this</span>.$data[key])</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对当前的key设置监听</span></span><br><span class="line">            <span class="keyword">new</span> Observer(<span class="keyword">this</span>, key, <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>&#123;</span><br><span class="line">                node.nodeValue = node.nodeValue.replace(oldVal, val)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentObserver = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历data，添加监听的observe方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!data || <span class="keyword">typeof</span> data !== <span class="string">'object'</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> data)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果下面的get方法直接返回data[key]会引起循环调用导致栈溢出</span></span><br><span class="line">        <span class="keyword">let</span> val = data[key]</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每一个key都有一个自己的subject</span></span><br><span class="line">        <span class="keyword">let</span> subject = <span class="keyword">new</span> Subject()</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            <span class="keyword">get</span>: function () &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'run get'</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// currentObserver是一个全局的对象</span></span><br><span class="line">                <span class="keyword">if</span>(currentObserver)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 订阅某一个subject（data中的某一个键值对的key）</span></span><br><span class="line">                    currentObserver.subscribeTo(subject)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> val</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>: function (newVal) &#123;</span><br><span class="line">                val = newVal</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'run set'</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更改了值，通知所有订阅者</span></span><br><span class="line">                subject.notify()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> val === <span class="string">'object'</span>)&#123;</span><br><span class="line">            observe(val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主题Subject，data中的每一个key都是一个subject</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="comment">// 一个主题会有多个订阅者，比如说在视图中会有多个地方有&#123;&#123;name&#125;&#125;</span></span><br><span class="line">        <span class="keyword">this</span>.observers = []</span><br><span class="line">    &#125;</span><br><span class="line">    addObserver(observer)&#123;</span><br><span class="line">        <span class="keyword">this</span>.observers.push(observer)</span><br><span class="line">    &#125;</span><br><span class="line">    notify()&#123;</span><br><span class="line">        <span class="keyword">this</span>.observers.forEach(<span class="function"><span class="params">observer</span>=&gt;</span>&#123;</span><br><span class="line">            observer.update()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅者Observer</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(vm, key, cb)&#123;</span><br><span class="line">        <span class="keyword">this</span>.vm = vm</span><br><span class="line">        <span class="keyword">this</span>.key = key</span><br><span class="line">        <span class="keyword">this</span>.cb = cb</span><br><span class="line"></span><br><span class="line">        <span class="comment">// currentObserver是一个全局的变量，设置他有值</span></span><br><span class="line">        <span class="comment">// 并执行下一行触发get方法，会运行observe方法中的订阅操作</span></span><br><span class="line">        currentObserver = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.getValue()</span><br><span class="line">        currentObserver = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    update()&#123;</span><br><span class="line">        <span class="keyword">let</span> oldVal = <span class="keyword">this</span>.value</span><br><span class="line">        <span class="keyword">let</span> value = <span class="keyword">this</span>.getValue()</span><br><span class="line">        <span class="keyword">if</span>(value !== oldVal)&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value</span><br><span class="line">            <span class="keyword">this</span>.cb.bind(<span class="keyword">this</span>.vm)(value, oldVal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    subscribeTo(subject)&#123;</span><br><span class="line">        subject.addObserver(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    getValue()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里会触发data中元素的get函数</span></span><br><span class="line">        <span class="keyword">let</span> value = <span class="keyword">this</span>.vm.$data[<span class="keyword">this</span>.key]</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 调用</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    this is &#123;&#123;name&#125;&#125;, &#123;&#123;age&#125;&#125; years old!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> MVVM(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            name: <span class="string">'jianqi'</span>,</span></span><br><span class="line">            age: 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="实现双向绑定"><a href="#实现双向绑定" class="headerlink" title="实现双向绑定"></a>实现双向绑定</h2><p>在vue中，如果要对一个input框进行双向绑定，需要设置v-model指令<br>这里我们进行相同的设置，对于设置了v-model的input实现双向绑定<br>在前面已经实现单向数据流的基础上很容易实现双向绑定<br>在解析dom时候检测v-model指令，对应的元素绑定监听事件，当值改变时触发设置data即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改上面代码的MVVM</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MVVM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    traverse(node)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.nodeType === <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.compileNode(node)</span><br><span class="line">            node.childNodes.forEach(<span class="function"><span class="params">childNode</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.traverse(childNode)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(node.nodeType === <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.renderText(node)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    compileNode(node)&#123;</span><br><span class="line">        <span class="keyword">let</span> attrs = [...node.attributes]</span><br><span class="line">        attrs.forEach(<span class="function"><span class="params">attr</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isDirective(attr.name))&#123;</span><br><span class="line">                <span class="keyword">let</span> key = attr.value</span><br><span class="line">                node.value = <span class="keyword">this</span>.$data[key]</span><br><span class="line">                <span class="keyword">new</span> Observer(<span class="keyword">this</span>, key, <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">                    node.value = newVal</span><br><span class="line">                &#125;)</span><br><span class="line">                node.oninput = <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">this</span>.$data[key] = e.target.value</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isDirective(attrName)&#123;</span><br><span class="line">        <span class="keyword">return</span> attrName === <span class="string">'v-model'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 调用</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    this is &#123;&#123;name&#125;&#125;, &#123;&#123;age&#125;&#125; years old!</span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">        &#123;&#123;name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> MVVM(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            name: <span class="string">'jianqi'</span>,</span></span><br><span class="line">            age: 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vue用了有段时间了，参考了github的文章，写了个简化版&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="https://luckyjq.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="vue" scheme="https://luckyjq.github.io/tags/vue/"/>
    
      <category term="源码" scheme="https://luckyjq.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>koa2入门</title>
    <link href="https://luckyjq.github.io/2019/06/29/koa2%E5%85%A5%E9%97%A8/"/>
    <id>https://luckyjq.github.io/2019/06/29/koa2入门/</id>
    <published>2019-06-28T16:00:00.000Z</published>
    <updated>2019-07-03T07:05:02.342Z</updated>
    
    <content type="html"><![CDATA[<p>大杂烩，记录贴。包含一个简版koa框架的核心实现</p><a id="more"></a><h2 id="前置知识：关于async和await的理解"><a href="#前置知识：关于async和await的理解" class="headerlink" title="前置知识：关于async和await的理解"></a>前置知识：关于async和await的理解</h2><p><a href="https://segmentfault.com/a/1190000007535316" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007535316</a></p><ul><li>await必须包裹在async函数里</li><li>async函数执行返回的是一个promise对象</li><li>await在等什么？等一个promise，获取他的resolve的值</li><li>如果await后面的promise返回的是reject的值，那么需要使用try，catch进行包裹</li></ul><h2 id="koa2原理（use和next）"><a href="#koa2原理（use和next）" class="headerlink" title="koa2原理（use和next）"></a>koa2原理（use和next）</h2><p>源码解读：<a href="https://zhuanlan.zhihu.com/p/34797505" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34797505</a></p><p>自己实现一个简版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合中间件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">middlewareList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//dispatch函数用于执行一个中间件</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> fn = middlewareList[i]</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line"></span><br><span class="line">                <span class="comment">//这里fn的第二个参数就相当于next</span></span><br><span class="line">                fn(ctx, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>))  <span class="comment">// promise</span></span><br><span class="line">            )</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LikeKoa2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.middlewareList = []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    use(fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>.middlewareList.push(fn)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createContext(req, res) &#123;</span><br><span class="line">        <span class="keyword">const</span> ctx = &#123;</span><br><span class="line">            req,</span><br><span class="line">            res</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.query = req.query</span><br><span class="line">        <span class="keyword">return</span> ctx</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleRequest(ctx, fn) &#123;</span><br><span class="line">        <span class="keyword">return</span> fn(ctx)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    callback() &#123;</span><br><span class="line">        <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middlewareList)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> ctx = <span class="keyword">this</span>.createContext(req, res)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.handleRequest(ctx, fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listen(...args) &#123;</span><br><span class="line">        <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.callback())</span><br><span class="line">        server.listen(...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = LikeKoa2</span><br></pre></td></tr></table></figure><h2 id="koa2的ctx对象"><a href="#koa2的ctx对象" class="headerlink" title="koa2的ctx对象"></a>koa2的ctx对象</h2><p>koa2的ctx封装了req和res，可以通过ctx直接取得，也可以通过ctx.request.xx的形式取得<br>常用的：</p><ul><li>ctx.params</li><li>ctx.request.query</li><li>ctx.request.header</li><li>ctx.request.body( 需要使用body-parser插件)</li></ul><h2 id="利用cookie和session进行鉴权"><a href="#利用cookie和session进行鉴权" class="headerlink" title="利用cookie和session进行鉴权"></a>利用cookie和session进行鉴权</h2><p>作为一个网站有些资源需要登陆才能访问，有些不登陆也可以浏览。<br>如何实现鉴权？常用的方法是cookie和session</p><p>这里假设session存储在服务端内存中，是一个数组SESSION[ ]</p><ol><li>用户访问某个url时，进行用户鉴权，有无cookie</li><li>没有cookie，响应设置cookie,比如userid: xxx01，在服务端SESSION[ ]中添加一个session{xxx01:{ }}</li><li>用户登陆，往SESSION中对应的session对象中写字段，比如username: xxx。此时SESSON数组中有一个session应该是这样的：ssession{xxx01:{username: xxx}}</li><li>请求时携带cookie，服务端获取userid去SESSION中进行查询，看username是否有值，判断是否登陆了</li></ol><p>注意事项：</p><ol><li>设置 cookie时应当设置过期时间</li><li>session存储在服务器中重启就没了，需要进行持久化。可以考虑存在redis中或者直接加密后返回到cookie也可以</li></ol><h2 id="koa2常用插件"><a href="#koa2常用插件" class="headerlink" title="koa2常用插件"></a>koa2常用插件</h2><h3 id="登陆鉴权相关"><a href="#登陆鉴权相关" class="headerlink" title="登陆鉴权相关"></a>登陆鉴权相关</h3><ol><li><p>koa-session（把session加密后存在cookie中，支持外部数据库）<br>源码解读文章：<a href="https://segmentfault.com/a/1190000012412299" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012412299</a></p></li><li><p>koa-generic-session，koa-redis（这两个配套可以存储session到redis）</p></li><li><p>Sequelize，操作mysql数据库（如果链接mysql需要安装mysql2驱动）</p></li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="js中try-catch只能捕捉同步错误"><a href="#js中try-catch只能捕捉同步错误" class="headerlink" title="js中try catch只能捕捉同步错误"></a>js中try catch只能捕捉同步错误</h3><p>异步代码的错误很难，通过使用promise和async和await可以简化异步的错误处理，使用try和catch<br>下面这样也是没用的，必须返回异步函数的promise包装</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/c25a5034d64bde05d67f38042b401d57.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这样才对</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/3cd5daadf1e308d2427851ebe6d8a691.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="AOP思想"><a href="#AOP思想" class="headerlink" title="AOP思想"></a>AOP思想</h3><p>自定义全局异常处理函数，最先注册，try next()即可，相当于调用链条</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/74e4ca944f57360564990c5ffc36c401.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="封装错误对象"><a href="#封装错误对象" class="headerlink" title="封装错误对象"></a>封装错误对象</h3><p>状态码<br>error code<br>error message<br>request url</p><h3 id="开发环境和生产环境的异常配置"><a href="#开发环境和生产环境的异常配置" class="headerlink" title="开发环境和生产环境的异常配置"></a>开发环境和生产环境的异常配置</h3><p>开发环境下全局的非httpError捕捉需要再抛出去，方便开发时候调试<br>生产环境就不要抛了</p><p>一个作业题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.nameA = <span class="string">'a'</span></span><br><span class="line">        <span class="keyword">this</span>.nameD = <span class="string">'d'</span></span><br><span class="line">    &#125;</span><br><span class="line">    validateA() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"A"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="keyword">this</span>.nameB = <span class="string">'b'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    validateB() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"B"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B()</span><br><span class="line"><span class="comment">// 编写一个函数findMembers,获取b的所有带前缀的属性和方法</span></span><br><span class="line"><span class="keyword">const</span> members = findMembers2(b, <span class="string">'name'</span>, <span class="string">'validate'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大杂烩，记录贴。包含一个简版koa框架的核心实现&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="https://luckyjq.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="nodejs" scheme="https://luckyjq.github.io/tags/nodejs/"/>
    
      <category term="koa2" scheme="https://luckyjq.github.io/tags/koa2/"/>
    
  </entry>
  
  <entry>
    <title>使用nodejs原生http开发api接口</title>
    <link href="https://luckyjq.github.io/2019/06/24/nodejs/"/>
    <id>https://luckyjq.github.io/2019/06/24/nodejs/</id>
    <published>2019-06-24T04:31:41.808Z</published>
    <updated>2019-06-27T08:44:54.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/11c864d28732342961f1effb6113e2a7.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><p>使用webstorm进行开发，新建项目，发现没有nodejs智能提示<br>安装node智能提示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/2110eec1a1bf50a7b86bada07987d3bd.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>通过npm init新建项目<br>两个好用的插件：<br>全局安装nodemon，支持热重载<br>项目安装cross-env，兼容操作系统</p><p>配置package.json的script选项<br>配置中的NODE_ENV=dev，当以npm run dev启动时，process.env.NODE_ENV的值就为dev</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dev"</span>: <span class="string">"cross-env NODE_ENV=dev nodemon ./bin/www.js"</span>,</span><br><span class="line"><span class="string">"prd"</span>: <span class="string">"cross-env NODE_ENV=production nodemon ./bin/www.js"</span></span><br></pre></td></tr></table></figure><h2 id="设计接口"><a href="#设计接口" class="headerlink" title="设计接口"></a>设计接口</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/69fbbfca44c776d80b9d9c62141f2919.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="响应结构设计"><a href="#响应结构设计" class="headerlink" title="响应结构设计"></a>响应结构设计</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成功</span></span><br><span class="line">&#123;</span><br><span class="line">    errno: <span class="number">0</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    message: <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//失败</span></span><br><span class="line">&#123;</span><br><span class="line">    errno: <span class="number">-1</span>,</span><br><span class="line">    message: <span class="string">''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过es6的class新建响应模型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data, message) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> data === <span class="string">'string'</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.message = data</span><br><span class="line">            data = <span class="literal">null</span></span><br><span class="line">            message = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(data) &#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(message)&#123;</span><br><span class="line">            <span class="keyword">this</span>.message = message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuccessModel</span> <span class="keyword">extends</span> <span class="title">BaseModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data, message)&#123;</span><br><span class="line">        <span class="keyword">super</span>(data, message)</span><br><span class="line">        <span class="keyword">this</span>.errno = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorModel</span> <span class="keyword">extends</span> <span class="title">BaseModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data, message)&#123;</span><br><span class="line">        <span class="keyword">super</span>(data, message)</span><br><span class="line">        <span class="keyword">this</span>.errno = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    SuccessModel,</span><br><span class="line">    ErrorModel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目结构拆分"><a href="#项目结构拆分" class="headerlink" title="项目结构拆分"></a>项目结构拆分</h2><p>将启动服务器封装成<a href="http://www.js，外部传入服务器响应函数" target="_blank" rel="noopener">www.js，外部传入服务器响应函数</a><br>响应函数在app.js中进行定义，函数中都可以引用req，res对象<br>对路由进行拆分，博客路由和用户路由，在app.js中进行引用<br>app.js中引用路由对所有请求拦截处理，有对应路由返回数据否则返回404<br>新建controller文件夹，主要用于操作数据，然后在router中引用对应controller中的方法<br>router中调用controller方法获得数据，封装成响应model并返回数据<br>新增配置文件，配置mysql和redis链接信息<br>封装mysql链接工具，封装执行sql函数</p><h2 id="对promise的一些疑惑"><a href="#对promise的一些疑惑" class="headerlink" title="对promise的一些疑惑"></a>对promise的一些疑惑</h2><h2 id="碰到的一些小bug"><a href="#碰到的一些小bug" class="headerlink" title="碰到的一些小bug"></a>碰到的一些小bug</h2><p>sql语句定义的不规范，${username}应该要加上引号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">`select username, realname from user where username=<span class="subst">$&#123;username&#125;</span> and password=<span class="subst">$&#123;password&#125;</span>`</span></span><br></pre></td></tr></table></figure><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p>1.访问日志<br>2.自定义日志，包括自定义事件，错误记录等</p><p>通过流对象写日志<br>日志的拆分，按照天等（通常用linux的定时任务crontab）</p><h2 id="sql注入的d防范"><a href="#sql注入的d防范" class="headerlink" title="sql注入的d防范"></a>sql注入的d防范</h2><p>使用mysql的escape函数，所有的字段先用escape转义<br>然后<code>dadaw${xxx}</code>中的${xx}就不用加引号了</p><p>npm xss模块</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总体架构&quot;&gt;&lt;a href=&quot;#总体架构&quot; class=&quot;headerlink&quot; title=&quot;总体架构&quot;&gt;&lt;/a&gt;总体架构&lt;/h2&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lig
      
    
    </summary>
    
      <category term="开发" scheme="https://luckyjq.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="nodejs" scheme="https://luckyjq.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>使用七牛云一键上传博客图片（mac）</title>
    <link href="https://luckyjq.github.io/2019/06/24/%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E4%B8%80%E9%94%AE%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%EF%BC%88mac)/"/>
    <id>https://luckyjq.github.io/2019/06/24/使用七牛云一键上传博客图片（mac)/</id>
    <published>2019-06-23T16:00:00.000Z</published>
    <updated>2019-07-02T13:40:13.875Z</updated>
    
    <content type="html"><![CDATA[<p>嘀～小姐姐秒上传到七牛云啦！</p><p>写博客的效率又提升了！</p><a id="more"></a><h2 id="随便BB"><a href="#随便BB" class="headerlink" title="随便BB"></a>随便BB</h2><p>hexo的博客很早之前就搭建了，零零散散写过几篇文章。<br>现在大学生活也结束了，即将步入研究生，打算好好利用这个暑假。<br>重新拾起博客，当作一个记录的小地方。</p><p>之前我很讨厌在hexo上写博客，因为图片配置是在是太麻烦了，首先得准备好博客的照片，然后上传到某一个图传，再拿到图片地址按照特定格式插入文章。这倒也还好，关键是那些免费图床老是容易挂。。。好不容易申请了七牛云，竟然需要给空间绑定域名，测试域名只能用一个月，蛋疼。</p><p>终于。。我申请好了独立域名，通过了备案，有了足够的时间和热情。。我又回坑了。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>Alfred是个什么我也没仔细研究，大概就是一个效率工具，最🐂的地方是它支持自定义脚本，然后实现自动化操作。所以我们就是要利用这个工具和七牛的开放SDK完成一个自动化操作。</p><p>当然。。有人已经写好了这个自动化脚本了<br>项目地址：<a href="https://github.com/jiwenxing/qimage-mac" target="_blank" rel="noopener">https://github.com/jiwenxing/qimage-mac</a></p><h2 id="正式开干"><a href="#正式开干" class="headerlink" title="正式开干"></a>正式开干</h2><h3 id="1-下载Alfred，需要使用他的收费功能，下面会给出破解版。"><a href="#1-下载Alfred，需要使用他的收费功能，下面会给出破解版。" class="headerlink" title="1.下载Alfred，需要使用他的收费功能，下面会给出破解版。"></a>1.下载Alfred，需要使用他的收费功能，下面会给出破解版。</h3><p>下载地址：<a href="https://pan.baidu.com/s/1mir5F6K" target="_blank" rel="noopener">https://pan.baidu.com/s/1mir5F6K</a><br>提取码：jj7s</p><h3 id="2-安装七牛云的SDK工具"><a href="#2-安装七牛云的SDK工具" class="headerlink" title="2.安装七牛云的SDK工具"></a>2.安装七牛云的SDK工具</h3><p>下载地址：<a href="https://developer.qiniu.com/kodo/tools/1302/qshell" target="_blank" rel="noopener">https://developer.qiniu.com/kodo/tools/1302/qshell</a><br>下载完后解压，把qshell_darwin_amd64文件重命名为qshell并移至usr/local/bin目录下即可。后面的脚本会引用这个SDK。</p><h3 id="3-注册七牛云账号并实名认证"><a href="#3-注册七牛云账号并实名认证" class="headerlink" title="3.注册七牛云账号并实名认证"></a>3.注册七牛云账号并实名认证</h3><p>自己去注册。最好再准备一个独立域名，因为七牛的测试域名有效期只有一个月。</p><h3 id="4-下载github脚本，运行qimage-alfredworkflow"><a href="#4-下载github脚本，运行qimage-alfredworkflow" class="headerlink" title="4.下载github脚本，运行qimage.alfredworkflow"></a>4.下载github脚本，运行<em>qimage.alfredworkflow</em></h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/0c049de0deb969fed678f02706238fc0.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>修改中间的 <em>Run Script</em>，具体操作见下面链接。<br><a href="https://github.com/jiwenxing/qimage-mac/issues/16" target="_blank" rel="noopener">https://github.com/jiwenxing/qimage-mac/issues/16</a></p><p>修改<em>Hotkey</em>进行自动化触发快捷键设置，推荐cmd+option+v。</p><p>现在你可以试一试了，cmd+c复制一张图片到剪切板，在md文件里cmd+option+v<br>😯 他返回了md的图片引用格式，写博客效率又提升了呢！</p><p>当然你可能会需要一些定制化的小变化，这时候你就要稍微读一下脚本然后进行修改了。</p><p>传个小姐姐试试水！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/21f8dcd2336c6dcc3e38938e769b75da.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>喂！小妹妹！你跟谁撒娇呢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嘀～小姐姐秒上传到七牛云啦！&lt;/p&gt;
&lt;p&gt;写博客的效率又提升了！&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://luckyjq.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://luckyjq.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="骚操作" scheme="https://luckyjq.github.io/tags/%E9%AA%9A%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>浏览器和nodejs的事件循环机制</title>
    <link href="https://luckyjq.github.io/2019/04/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8Cnodejs%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <id>https://luckyjq.github.io/2019/04/21/浏览器和nodejs的事件循环机制/</id>
    <published>2019-04-20T16:00:00.000Z</published>
    <updated>2019-07-29T06:24:46.323Z</updated>
    
    <content type="html"><![CDATA[<p>事件循环，画个圈圈……</p><a id="more"></a><h2 id="浏览器的事件循环机制"><a href="#浏览器的事件循环机制" class="headerlink" title="浏览器的事件循环机制"></a>浏览器的事件循环机制</h2><p>浏览器事件循环图（摘自《javascript忍者秘籍第二版》13章）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/1e7b48b68e4388149a47ecdb57761ba0.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="宏任务微任务"><a href="#宏任务微任务" class="headerlink" title="宏任务微任务"></a>宏任务微任务</h3><p><strong>宏任务：从浏览器角度，代表一个离散的，独立的工作单元</strong><br>比如：创建主文档对象，解析HTML，执行主线（全局）js代码<br>更改当前URL和各种事件（页面加载，网络事件，定时器等）</p><p><strong>微任务：是更小的任务，微任务要尽可能快的，通过异步方式执行</strong><br>比如：DOM变化（MutationObserver），Promise回调函数<br>由于因为async await 本身就是promise+generator的语法糖，所以await后面的也是</p><h3 id="从面试题理解运行机制"><a href="#从面试题理解运行机制" class="headerlink" title="从面试题理解运行机制"></a>从面试题理解运行机制</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 写出输出</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>上面的代码执行结果为：2，4，3，1<br>我们结合上面的事件循环图来理解下输出结果</p><ol><li>首先执行主线（全局js代码），碰到定时器代码，定时器时间为0表示尽快执行<br>定时器是宏任务，于是把定时器任务放入宏任务队列<br>现在宏任务队列中是（主线，定时器）</li><li>接着往下解析，开始执行promise的代码，遇到promise里的2直接输出</li><li>promise中有一个异步方法，是微任务，于是把他放到微任务队列</li><li>继续往下执行全局代码，输出4</li><li>跑完上面的流程，js主线（全局）代码执行完成，同时也是第一个宏任务执行完成了</li><li>按照事件循环图的流程，开始检查微任务队列是否有任务，有的话执行所有微任务，输出3</li><li>第一轮循环结束，更新UI主线（全局）任务从宏任务中出队</li><li>开始新的一轮事件循环，执行队首的宏任务即之前的定时器任务输出1</li></ol><p>通过上面的例子我们也可以知道，定时器的执行时间机制：<br>因为js单线程的本质，<strong>我们只能控制定时器何时被加入宏任务队列，而无法控制其何时执行</strong></p><p>再看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//请写出输出内容</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">script start</span></span><br><span class="line"><span class="comment">async1 start</span></span><br><span class="line"><span class="comment">async2</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">script end</span></span><br><span class="line"><span class="comment">async1 end</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">setTimeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>上面这个例题可能会有一些地方难理解，主要是async和await</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line"><span class="keyword">await</span> async2();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve(async2()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nodejs的事件循环机制"><a href="#nodejs的事件循环机制" class="headerlink" title="nodejs的事件循环机制"></a>nodejs的事件循环机制</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事件循环，画个圈圈……&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://luckyjq.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://luckyjq.github.io/tags/js/"/>
    
      <category term="nodejs" scheme="https://luckyjq.github.io/tags/nodejs/"/>
    
      <category term="基础" scheme="https://luckyjq.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>理解typeof和instanceof</title>
    <link href="https://luckyjq.github.io/2019/04/17/%E7%90%86%E8%A7%A3typeof%E5%92%8Cinstanceof/"/>
    <id>https://luckyjq.github.io/2019/04/17/理解typeof和instanceof/</id>
    <published>2019-04-17T09:34:32.000Z</published>
    <updated>2019-07-03T01:36:52.458Z</updated>
    
    <content type="html"><![CDATA[<p>理解typeof和instanceof，从原型开始说起</p><a id="more"></a><h2 id="typeof判断类型存在的问题"><a href="#typeof判断类型存在的问题" class="headerlink" title="typeof判断类型存在的问题"></a>typeof判断类型存在的问题</h2><p>对于这两个js关键词，一直停留在很浅显的理解上。<br>直到最近开始刷个大公司的面试题，发现这一知识点出场之高，决心总结一下。</p><p>typeof判断类型，截图来自MDN。<br>问题出现了，当类型为Null和Array和Object时候，均返回“object”，如何区别？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/943056903a1e3c5bb07bc83a471fa457.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>一种常用的检测方法是使用：<br>Object.prototype.toString.call(obj)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">12</span>,<span class="string">'aaa'</span>]</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr)  <span class="comment">//"[object Array]"</span></span><br></pre></td></tr></table></figure><p>为什么要使用Object原型上的toString方法，而不是直接调用？<br>因为Array ，function等类型作为Object的实例，都重写了toString方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.toString()  <span class="comment">//"12,aaa"</span></span><br></pre></td></tr></table></figure><p>但是使用上面这种方法判断也存在局限性，对于任何对象，返回都是相同的。我们现在的需求是有不同构造函数比如Student，Dog等等，我们new一个实例的时候想判断这个实例是一个Dog还是一个Student，这时候就需要用到instanceof。</p><h2 id="instanceof大法好"><a href="#instanceof大法好" class="headerlink" title="instanceof大法好"></a>instanceof大法好</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = <span class="function"><span class="keyword">function</span> (<span class="params">name,age</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name</span><br><span class="line"><span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`i am <span class="subst">$&#123;name&#125;</span>,and i am <span class="subst">$&#123;age&#125;</span> years old!`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">'Tom'</span>, <span class="number">20</span>)</span><br><span class="line">stu <span class="keyword">instanceof</span> Student   <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>要理解instanceof肯定逃不过原型链，祭出原型链大图<br>（如果还不理解原型链可以参考其他文章，要求能把下面图看懂）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://gitblog.luckyq.cn/1f5e2ac23cb0ea276d64256d63949f07.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>关键点：<br>首先，js中一切都是对象，函数也是对象<br>所有的函数都有prototype和<strong>proto</strong>属性<br>所有的对象都有<strong>proto</strong>属性<br>Object.prototype是所有对象的根<br>Function.prototype是所有函数的根<br>Object和Function都是构造函数</p><p>instanceof的判断原理很简单，就是在实例的<strong>proto</strong>链条上寻找，如果有就返回true<br>通过上面的图也可以理解几个很奇怪的instanceof判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>这两天看书，发现自己对instanceof的使用有个地方还是不清楚</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.dance = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ninja</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Ninja.prototype = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">const</span> ninja = <span class="keyword">new</span> Ninja()</span><br></pre></td></tr></table></figure><p>一般的js继承写法，一开始我想的是：<br>Ninja.prototype被改写成一个Person实例对象了<br>所以:<br>ninja instanceof Ninja返回false，<br>ninja instanceof Person 返回true</p><p>但是测试返回的是两个true</p><p>到底该如何理解instanceof?<br><strong>检查右边的函数原型是否存在于操作符左边的对象的原型链上</strong><br>Ninja.prototype 是否在ninja对象的<strong>proto</strong>链上</p><p>当你实例化时候，const ninja = new Ninja()<br>判断ninja instanceof Ninja时，就看Ninja.prototype是否在ninja实例的<strong>proto</strong>链条上<br>而Ninja.prototype是new Person，在ninja实例的<strong>proto</strong>链条上，所以就返回true<br>这样才是正确理解instanceof的方式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;理解typeof和instanceof，从原型开始说起&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://luckyjq.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://luckyjq.github.io/tags/js/"/>
    
      <category term="基础" scheme="https://luckyjq.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
