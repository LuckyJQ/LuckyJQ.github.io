[{"title":"【深挖】浏览器输入 url 到页面的展现发生了什么（前端网络篇）","date":"2019-08-14T16:00:00.000Z","path":"2019/08/15/浏览器输入 url 到页面的展现发生了什么/","text":"对前端相关的网络问题进行一次探究。这篇文章将按照DNS解析，TCP连接的建立，HTTP缓存和状态码，浏览器的渲染的顺序来探究。长文预警。 前言对于这个问题浏览器输入 url 到页面的展现发生了什么，经常可以在各大面试经验贴中看到，个人的理解也是和一般笼统的答案差不多： 在浏览器地址栏输入URL浏览器解析URL获取协议，主机，端口，path浏览器组装一个HTTP（GET）请求报文浏览器获取主机ip地址打开一个socket与目标IP地址，端口建立TCP链TCP链接建立后发送HTTP请求服务器将响应报文通过TCP连接发送回浏览器，浏览器接收HTTP响应根据资源类型决定如何处理（假设资源为HTML文档）解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本最后展现出来给用户 关于准备面试，我想到这个地步就可以了吧？emm，直到我看到这篇文章。 这位阿里的面试官这样说道： 基本如果应聘者只回到了上述步骤，很多关键步骤（前端应该了解的知识点）没有提及，那么基本凉凉一半了。这里简述下笔者感觉，这其中你应该具体展开说明的。 浏览器发送请求，是否需要查看缓存？是否请求资源在缓存中并且新鲜，跳转到转码步骤？如果资源已经缓存，是否新鲜？如何检查？怎么判断、http1.0 和 http1.1 的区别是什么，这些字段的优先级是怎么样子的。 浏览器解析 url 获取协议，过程是什么？DNS 递归查询可否介绍下？ 建立 TCP 链接的三次握手是否可以介绍下? 服务器接受到请求，是否需要检查缓存？检查什么字段？什么样的缓存会需要服务端检查？ 服务端发送 TCP 链接，浏览器接受 http 相应后，根据什么来决定是否需要关闭连接？关闭 TCP 的四次挥手是什么？ 浏览器是否需要检查状态码，有哪些状态码？（笔者高频考码：304、200） 在解析的时候，具体如何解析、是否有顺序。（重绘重排高频考题就在这里） 总结如上、我们是否可以给出一些基本的网站优化手段？ 龟龟，这些东西好像都知道一点，但缺乏系统的整理，磨砺两可。所以这篇文章将按照DNS解析，TCP连接的建立，HTTP缓存和状态码，浏览器的渲染的顺序来探究。 DNS解析过程解析原理要想建立连接发送数据，首先需要知道服务器的ip地址。DNS协议用于查找某个域名对应的ip。DNS服务器采用分布式分层架构，通常来说有以下几类： 根DNS服务器 顶级DNS服务器（简称TLD，负责顶级域名.com .cn之类的）， 权威DNS服务器（一般为一个组织的DNS服务器，比如我用腾讯云，他有自己的DNS服务器。最终要查询我的主机的ip是要找到这台DNS服务器的呃） 本地DNS服务器（一个区域内的DNS服务器，用来转发该区域内用户的DNS查询请求） 下图是一次DNS请求的示意图，比如我要查询自己网站luckyq.cn的ip地址 DNS解析请求首先发到了本地DNS服务器，如果本地DNS服务器有对应域名的DNS记录缓存，则本地DNS服务器将直接返回给我。缓存记录设置有实效时间，比如我的域名在配置时设置的过期时间为600秒。 如果本地DNS服务器中没有对应的缓存，本地DNS服务器将询问根服务器（如果此时本地DNS服务器有对应TLD的缓存则跳过根DNS服务器）。根服务器查询.cn域名对应的DNS服务器，然后返回给本地DNS服务器。 现在本地DNS服务器知道了.cn DNS服务器的地址，向.cn TLD DNS服务器发送查询请求。以我为例，在腾讯云购买并注册域名时，绑定了我的域名luckyq.cn和ip地址123.206.25.72。 腾讯云在向.cn DNS服务注册时会添加两条记录： luckyq.cn, f1g1ns1.dnspod.net, NS f1g1ns1.dnspod.net, 14.215.150.17, A 现在进行查询的时候，查到luckyq.cn所解析的权威DNS名称和IP地址，将信息返回给本地DNS服务器。 本地DNS服务器向权威服务器进行查询，根据我的网站域名查询到了ip，返回。得到ip后客户端和服务器就可以进行通信了。 DNS请求抓包分析命令：dig +trace luckyq.cn+trace的含义是跟踪整个DNS解析的过程luckyq.cn是我网站的域名，ip地址为123.206.25.72下图是命令行返回的结果 wireshark抓取数据包，毕竟过滤出本次请求相关的包 根据上图我们可以看到： 第一条表示我向本地DNS服务器（61.130.254.34）请求根DNS服务器的地址 第二条，本地dns服务器向本机返回了13个顶级域的NS记录和A记录 在拿到13个顶级域的域名后，本机开始向本地DNS服务器请求13个顶级域的ip地址（🤔这里其实我有点疑惑，上一条不是已经返回NS和A记录了吗，为什么后面还要对13个顶级域名的ip都询问一遍。可能的原因是第一条本机查询时只要了NS记录，所以本机只关心NS记录）。在本地DNS返回顶级DNS域名后，本机就可以开始询问了。192.5.5.241#53(f.root-servers.net)最先返回了cn的顶级NS和A记录。接着就和上面的过程类似了，询问本机各cn顶级DNS的ip，然后接着查询。 203.119.28.1#53(d.dns.cn)最先返回了要查询的权威DNS的NS记录（腾讯云的DNS服务器），然后本机询问本地DNS服务器ip，最后查询相应ip返回结果。 注：上一次实验过了几分钟，当你再次执行相应命令并抓包时，会发生什么？（🤔为什么只有这么几个包）个人觉得原因是：上一次查询刚过不久，本地DNS缓存了一些A记录，比如根DNS服务器域名和ip的对应关系，cn顶级DNS服务器域名和ip对应的关系，所以本机不再向本地DNS服务器进行询问，减少了很多包。 客户端和服务器如何建立连接TCP请求头结构当年考研的时候看计算机网络，看的是计算机网络自顶向下（这本书很不错，推荐）。整体给我的感觉是网络这块协议很复杂。不过好歹学过，七层协议，各层协议主要是干嘛的，一些专业术语还是有印象的。不过你要问我TCP协议具体的请求头结构，三次握手的细节这些我可能就记不太清了（所以想记录下来）。我会在这一节先回顾下TCP协议请求头的结构，一些特别基础的知识就不在本文写了。下图是TCP请求头的结构。 TCP三次握手在上一节中，客户端获取了服务器的ip地址，两者开始建立TCP连接。建立TCP连接时，就要说到经典的三次握手。下图是对访问知乎的抓包。前三个数据包就是三次握手。 在TCP连接建立和销毁时，总共有11种TCP的状态，具体如下表。 TCP状态 含义 LISTEN 侦听来自远方的TCP端口的连接请求 SYN-SENT 发送连接请求后等待匹配的连接请求（客户端） SYN-RECEIVED 收到和发送一个连接请求后等待对方对连接请求的确认（服务器） ESTABLISHED 代表一个打开的连接 FIN-WAIT-1 等待远程TCP连接中断请求，或先前的连接中断请求的确认 FIN-WAIT-2 收到和发送一个连接请求后等待对方对连接请求的确认（服务器） CLOSE-WAIT 等待从本地用户发来的连接中断请求 CLOSING 等待远程TCP对连接中断的确认 LAST-ACK 等待原来的发向远程TCP的连接中断请求的确认 TIME-WAIT 等待足够的时间以确保远程TCP接收到连接中断请求的确认 CLOSED 没有任何连接状态 下面就结合抓包的数据和状态变化来分析TCP三次握手 第一次握手，客户端发送数据包，将SYN标志位置为1，表示要建立连接，且序列号Seq=0。此时客户端的TCP状态由CLOSED变为SYN-SENT。 第二次握手，服务端收到客户端数据包后，将自己的SYN，ACK标识位设置为1，表示建立连接和收到。服务端也会指定一个新的序列号Seq=0。Ack=1表示服务端下一个期望收到的包序列是1。到此时，服务端的TCP状态由CLOSED到LISTEN到SYN-RECEIVED。 第三次握手，客户端收到包后将自己的ACK置为1表示收到，并且Seq变为1。此时客户端处于ESTABLISHED状态。 服务端收到客户端的ACK包后也处于ESTABLISHED状态，双方建立连接开始发送数据。 加上HTTPS一般来说，浏览器访问服务器，https的建立流程如下图（网上偷的图）在连接的建立过程中，涉及到比较重要的三个算法： 非对称加密算法（用于保证传输的内容不被破解），常用的算法是RSA，关于RSA算法的原理可以参考阮老师的文章。RSA算法原理 对称加密算法（由于非对称加密需要较大的运算量，所有的传输数据不可能都用非对称加密算法加密，一般而言是用非对称加密算法确保双方安全拿到对称加密算法的信息，后续的数据传输就用双方都知道的对称加密算法进行通信）。 散列hash算法（用于确保数据的完整性）。 如果你对一些专有名词比如数字证书，上面提到的算法用途还不太清楚，建议先阅读下文末参考链接中和https相关的文章。下面我将直接访问京东首页并抓包分析https的建立过程。 client_hello客户端发起请求，以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息。 server_hello+certificate+server_key_exchange+sever_hello_done server_hello。服务端返回协商的信息结果，包括选择使用的协议版本，选择的加密套件cipher suite，选择的压缩算法 compression method、随机数等，其中随机数用于后续的密钥协商. certificate。发送服务器证书，将服务器配置的证书（链）发送到客户端（用户证书在前，上级证书在后）。 server_key_exchange 。对于使用DHE/ECDHE非对称密钥协商算法的SSL握手，将发送该类型握手(查阅的资料，后面打算g研究下各种加密算法的区别)。 server_hello_done。通知客户端 server_hello 信息发送结束。 客户端进行证书校验。客户端验证证书的合法性，如果验证通过才会进行后续通信，否则根据错误情况不同做出提示和操作，合法性验证主要包括证书链的可信性，有效期，是否吊销，域名是否匹配等。 client_key_exchange+change_cipher_spec+encrypted_handshake_message TCP四次挥手emm，关于四次挥手我抓包了很多网站，发现区别很大，下面以西电的官网为例讲解四次挥手的过程。 第一次挥手，客户端将标志位FIN置为1，表示想断开连接。报文中会指定一个序列号，此时客户端处于FIN_WAIT1状态。 第二次挥手，服务端把客户端的序列号 + 1 作为 报文的序列号，表明已经收到客户端的报文了，此时服务端处于CLOSE_WAIT状态。 第三次挥手，如果服务端也想断开连接了，和客户端的第一次挥手一样将 FIN 置为1，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。 第四次挥手，客户端收到服务端ACK报文之后进入FIN_WAIT2状态。此时如果发送一个报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，则客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入CLOSED 状态 服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 常见问题： 为什么挥手要4次，握手只要3次？ 挥手的时候，客户端请求断开时服务端可能还没发完最后的数据，因此需要先回应一下客户端，等数据发完后再发起断开请求。 为什么要有TIME_WAIT状态而不是马上关闭连接？ 要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 第三次挥手的FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。 挥手一定是四次吗？从我抓了几个网站的包来看其实并不一定。比如知乎： http缓存探究浏览器的渲染机制参考资料 《计算机网络自顶向下（第七版）》 作为前端的你了解多少tcp的内容 工程师最容易搞错的域名知识 DNS 原理入门 TCP请求头 tcp连接全过程各种状态详解 HTTPS协议详解(四)：TLS/SSL握手过程 SSL/TLS协议运行机制的概述 HTTPS协议详解(三)：PKI 体系 看图学HTTPS HTTP 缓存机制一二三 HTTP1.0、HTTP1.1 和 HTTP2.0 的区别","tags":[{"name":"网络","slug":"网络","permalink":"https://luckyjq.github.io/tags/网络/"},{"name":"面试","slug":"面试","permalink":"https://luckyjq.github.io/tags/面试/"}]},{"title":"【译】JavaScript作用域链中的标识符解析和闭包","date":"2019-07-29T16:00:00.000Z","path":"2019/07/30/JavaScript作用域链中的标识符解析和闭包/","text":"这篇翻译紧接上一篇，建议先阅读JavaScript作用域链中的标识符解析和闭包。 从我之前的文章中，我们知道每个函数调用时都有一个关联的执行上下文，其中包含一个变量对象[VO]，它由给定函数内部定义的所有变量，函数和参数组成。 每个执行上下文的作用域链属性只是当前上下文的[VO] +所有父级的[VO]的集合。 12Scope = VO + All Parent VOsEg: scopeChain = [ [VO] + [VO1] + [VO2] + [VO n+1] ]; 确定作用域链中的变量对象[VO]我们现在知道作用域链的第一个[VO]属于当前执行上下文，我们可以通过查看他的父上下文的作用域链来找到剩余的父[VO]： 1234567891011121314151617function one() &#123; two(); function two() &#123; three(); function three() &#123; alert('I am at function three'); &#125; &#125;&#125;one(); 这个例子很简单，从全局上下文开始，我们调用one（），one（）调用two（），然后调用three（），three函数弹出一个alert。上面的图像显示了执行上下文堆栈的情况。我们可以看到此时的three作用域链如下所示：three() Scope Chain = [ [three() VO] + [two() VO] + [one() VO] + [Global VO] ]; 词法作用域要注意的JavaScript的一个重要特性是，解释器使用词法作用域，而不是动态作用域。对所有内部函数来说，他们静态的绑定到父上下文中，即他们在代码中被定义的地方（个人理解为javascript的函数作用域在函数定义时确定，而非调用时）。 在上面的上一个例子中，three将始终静态绑定到two，而two依次绑定到one，依此类推。这给出了链接效果，其中所有内部函数都可以通过静态绑定的作用域链访问外部函数VO。 这个词法作用域是许多开发人员混淆的根源。我们知道每次调用函数都会创建一个新的执行上下文和相关的VO，它保存在当前上下文中计算的变量值。 正是这种对VO的动态的，运行时的评估以及每个上下文的词法作用域，导致程序行为出现意外结果。采用以下经典示例： 123456789101112131415var myAlerts = []for (var i = 0; i &lt; 5; i++) &#123; myAlerts.push( function inner() &#123; alert(i) &#125; )&#125;myAlerts[0](); // 5myAlerts[1](); // 5myAlerts[2](); // 5myAlerts[3](); // 5myAlerts[4](); // 5 乍一看，那些刚接触JavaScript的人会认为alert弹出的i是定义函数的每个增量的i的值，所以aleert将分别警告1,2,3,4和5。 这是最常见的混淆点。函数inner是在全局上下文中创建的，因此其作用域链静态地绑定到全局上下文。 第11~15行调用inner（），它将在inner.ScopeChain中查找解析i，而inner函数定义在全局上下文中。当for循环结束时，i已经增加到5，每次调用inner时都会得到相同的结果。静态绑定的作用域链，含有来自包含实时变量的每个上下文的[VOs]，通常会让开发人员感到意外。 确定变量的值以下示例alert变量a，b和c的和，它给出了6的结果。 第14行很有趣，乍一看似乎a和b不在函数three内，所以这段代码怎么还能运行？要理解解释器如何评估此代码，我们需要在执行第14行时查看函数three的作用域链： 当解释器执行第14行：alert（a + b + c）时，它通过查看作用域链并检查第一个变量对象，即[three( ) VO]。它会检查[three( ) VO]中是否存在a，但是找不到具有该名称的任何属性，因此继续检查下一个[VO]。 解释器按顺序检查每个[VO]是否存在变量名，如果存在值将返回到原始计算代码，否则程序将抛出ReferenceError。因此，给定上面的示例，您可以看到在函数three的作用域链中，a，b和c都是可解析的。 闭包是怎么工作的在JavaScript中，闭包通常被认为是某种魔法，只有高级开发人员才能真正理解，但事实上，它只是对作用域链的简单理解。正如Douglas Crockford所说，闭包只是： An inner function always has access to the vars and parameters of its outer function, even after the outer function has returned… 内部函数始终能够访问外部函数的变量和参数，即使外部函数已经被返回 下面的代码是一个闭包的例子： 12345678910function foo() &#123; var a = 'private variable'; return function bar() &#123; alert(a); &#125;&#125;var callAlert = foo();callAlert(); // private variable 全局上下文有一个名为foo的函数和一个名为callAlert的变量，它保存foo( )返回的值。开发人员常常感到惊讶和困惑的是，即使在foo完成执行后，foo的私有变量a仍然可以被callAlert访问。 如果我们详细查看每个上下文，我们将看到以下内容： 123456789101112131415161718// Global Context when evaluatedglobal.VO = &#123; foo: pointer to foo(), callAlert: returned value of global.VO.foo scopeChain: [global.VO]&#125;// Foo Context when evaluatedfoo.VO = &#123; bar: pointer to bar(), a: 'private variable', scopeChain: [foo.VO, global.VO]&#125;// Bar Context when evaluatedbar.VO = &#123; scopeChain: [bar.VO, foo.VO, global.VO]&#125; 现在我们可以通过调用callAlert来看到，我们得到函数foo( )返回值，它返回指向bar函数的指针。在执行bar函数时，bar.VO.scopeChain是[bar.VO，foo.VO，global.VO]。 alert(a)，解释器检查bar.VO.scopeChain中的第一个VO，查找名为a的属性但找不到匹配项，因此立即转到下一个VO，foo.VO。 它检查属性的存在，这次找到一个匹配，将值返回到bar上下文，这解释了为什么即使foo已经完成执行，还是能访问’私有变量’a。 到此为止，我们已经涵盖了作用域链及其词法作用域的细节，以及闭包和变量解析是如何工作。本文的其余部分将讨论与上述内容相关的一些有趣情况。 原型链是如何影响变量的？JavaScript本质上是基于原型链的，除了null和undefined之外，语言中的几乎所有内容都是对象。当试图访问对象上的属性时，解释器将尝试通过查找对象中的属性。如果它找不到属性，它将继续查找原型链，这是一个继承的对象链，直到它找到属性，或遍历到链的末尾。 这导致了一个有趣的问题，解释器是先使用作用链还是原型链解析对象属性？两者都会使用。尝试解析属性或标识符时，将首先使用作用链来寻找对象。找到对象后，将遍历该对象的原型链，查找属性名称。我们来看一个例子： 12345678910111213var bar = &#123;&#125;;function foo() &#123; bar.a = 'Set from foo()' return function inner() &#123; alert(bar.a); &#125;&#125;foo()(); // 'Set from foo()' 第5行在全局对象bar上创建属性a，并将其值设置为‘Set from foo()’。解释器查找作用域链，并按预期在全局上下文中查找bar.a。现在，让我们考虑以下内容： 12345678910111213var bar = &#123;&#125;;function foo() &#123; Object.prototype.a = 'Set from prototype'; return function inner() &#123; alert(bar.a); &#125;&#125;foo()(); // 'Set from prototype()' 在运行时，我们调用inner函数，它试图通过在其作用域链中查找bar的存在来解析bar.a。它在全局上下文中找到bar，并进入搜索bar以查找名为a的属性。但是，a从未在bar上设置，因此解释器遍历bar对象的原型链并发现在Object.prototype上设置了一个。 这种行为解释了标识符的解析：在作用链中找到对象，然后继续向上找对象的原型链，直到找到属性，或返回undefined。 什么时候使用闭包闭包是一个强大的JavaScript概念，使用它们的一些最常见的情况是： 封装允许我们在暴露受控公共接口的同时，从外部作用域隐藏上下文的实现细节。这通常被称为模块模式或揭示模式。 回调也许闭包最强大的用途之一就是回调。浏览器中的JavaScript通常在单线程事件循环中运行，阻止其他事件直到当前事件执行完成。回调允许我们以非阻塞方式推迟对函数的调用，通常是为了响应事件的完成。这方面的一个例子是在对服务器进行AJAX调用时，使用回调来处理响应，同时仍然保持创建它的绑定。 闭包作为参数我们还可以将闭包作为参数传递给函数，这是一个强大的函数范例，用于为复杂代码创建更优雅的解决方案。以最小排序函数为例，通过将闭包作为参数传递，我们可以为不同类型的数据排序定义实现，同时仍然重用单个函数体作为原理图。 什么时候不使用闭包虽然闭包很强大，但由于某些性能问题，应该谨慎使用它们： 长作用域链多个嵌套函数是您可能遇到某些性能问题的典型信号。请记住，每次需要确定变量值时，必须遍历作用链以查找标识符，因此不言而喻，作用域链越长，查找时间越长。 垃圾收集JavaScript是一种自带垃圾收集的语言，这意味着与低级编程语言不同，开发人员通常不必担心内存管理。但是，这种自动垃圾收集通常会导致开发人员应用程序遭受性能不佳和内存泄漏的困扰。 不同的JavaScript引擎实现垃圾收集略有不同，因为ECMAScript没有定义应该如何处理实现，但是当尝试创建高性能，无泄漏的JavaScript代码时，相同的理念可以应用于引擎。一般来说，当对象无法被程序中运行的任何其他活动对象引用或无法访问时，垃圾收集器将尝试释放该对象的内存。 循环引用不太喜欢原文的内容，后续找个好的例子 原文地址传送：http://davidshariff.com/blog/javascript-scope-chain-and-closures/","tags":[{"name":"js","slug":"js","permalink":"https://luckyjq.github.io/tags/js/"},{"name":"基础","slug":"基础","permalink":"https://luckyjq.github.io/tags/基础/"},{"name":"翻译","slug":"翻译","permalink":"https://luckyjq.github.io/tags/翻译/"}]},{"title":"【译】JavaScript执行上下文和执行上下文堆栈是什么","date":"2019-07-28T16:00:00.000Z","path":"2019/07/29/javascript执行上下文和堆栈是什么/","text":"在这篇文章中，我将深入探讨JavaScript的一个最基本的部分，即执行上下文。在本文结束时，您应该更清楚地了解js解释器尝试做什么，为什么某些函数/变量可以在他们声明前使用，以及它们的值是如何确定的。 什么是执行上下文当js代码运行时，它的执行环境非常重要，并且为以下之一： 全局代码：首次执行代码的默认环境。 函数代码 - 每当执行流程进入函数体时。 Eval代码 - 要在内部eval函数内执行的文本。 你可能在网上读了很多文章关于作用域，这篇文章的目的是让你更容易的理解他们。让我们将执行上下文视为当前正在运行代码的环境/作用域。现在我们来看一个简单的例子，包含全局和函数（局部）环境下运行代码。 这里没有什么特别之处，我们有一个由紫色边框表示的全局上下文和由绿色，蓝色和橙色边框表示的3个不同的函数上下文。只能有1个全局上下文，并且它可以被程序中的任何其他上下文访问。 您可以拥有任意数量的函数上下文，并且每个函数调用都会创建一个新的上下文，从而创建一个私有作用域，在函数内部声明的任何内容都无法从当前函数作用域外直接访问。在上面的示例中，函数可以访问在其当前上下文之外声明的变量（全局上下文中的变量），但外部上下文无法访问person函数中的变量/函数。为什么会这样？这段代码究竟是如何评估的？ 执行上下文栈浏览器中的JavaScript解释器实现为单线程。这实际上意味着在浏览器中一次只能发生一件事，其他动作或事件在所谓的执行堆栈中排队。下图是单线程堆栈的抽象视图： 我们已经知道，当浏览器首次加载脚本时，它默认进入全局执行上下文。如果在全局代码中调用一个函数，程序的顺序流进入被调用的函数，创建一个新的执行上下文并将该上下文推送到执行堆栈的顶部。 如果在当前函数中调用另一个函数，则会发生同样的事情。代码的执行流程进入内部函数，该函数创建一个新的执行上下文，该上下文被推送到现有堆栈的顶部。浏览器将始终执行位于堆栈顶部的当前执行上下文，并且一旦函数完成执行当前执行上下文，它将从堆栈顶部弹出，将控制权返回到当前堆栈中的下一个z上下文。下面的示例显示了递归函数和程序的执行堆栈： 代码只调用自身3次，将i的值递增1.每次调用函数foo时，都会创建一个新的执行上下文。一旦上下文完成执行，它就会弹出堆栈并且控制返回到它下面的上下文，直到再次达到全局上下文。 有五个关键点可以帮助你记忆执行上下文 单线程 同步执行代码 一个全局环境 可以有很多个函数环境 每个函数调用都会创建一个新的执行上下文，对自身的调用也是 执行上下文的细节现在我们知道每次调用一个函数时，都会创建一个新的执行上下文。但是，在JavaScript解释器中，对执行上下文的每次调用都有两个阶段： 创建（准备）阶段（函数被调用，但是函数内部代码还未执行） 创建范围链 创建变量，函数和函数参数 确定“this”的值 激活/代码执行阶段（ 分配值，引用函数，解释/执行代码 我们可以将每个执行上下文在概念上表示为具有3个属性的对象： 123456789executionContextObj = &#123; 'scopeChain': &#123;&#125;, 'variableObject': &#123; // 函数的参数/传入的参数 // 内部函数 // 内部变量 &#125;, 'this': &#123;&#125;&#125; 变量对象[VO] / 激活对象[AO]executionContextObj在函数调用时创建，但是在函数代码被执行之前。这就是我们之前说的第1阶段，即准备阶段。在这阶段，解释器通过扫描传入的参数或函数的参数，本地函数声明，局部变量声明来创建executionContextObj。此扫描的结果将成为executionContextObj中的variableObject。 以下是解释器如何评估代码的伪概述： 发现某些代码调用了一个函数 在执行这个函数的代码前，创建了这个函数的执行上下文（execution context） 进入执行的第一阶段，准备阶段 初始化作用域链（scope chain） 创建名为arguments的对象。检查调用函数的参数，初始化参数名字和值（个人理解为把调用函数的实参复制一份放到VO中，都说js函数是值传递大概和这里关系很密切） 扫描函数内容寻找函数定义 对于找到的每个函数，在变量对象中创建一个属性，该属性是确切的函数名称，该属性具有指向内存中函数的引用指针 如果函数名已存在，则将覆盖引用指针值 扫描函数寻找变量定义 对于找到的每个变量声明，在变量对象中创建一个属性，该属性是变量名称，并将值初始化为undefined 如果变量名称已存在于变量对象中，则不执行任何操作并继续扫描 确定上下文中“this”的值 激活对象 / 代码执行阶段执行函数代码，并在代码逐行执行时分配变量值 举个例子： 12345678910function foo(i) &#123; var a = 'hello' var b = function privateB() &#123; &#125;; function c() &#123; &#125;&#125;foo(22) 当执行foo(22)调用函数时，该函数的执行上下文在准备阶段应该是下面这样的： 1234567891011121314fooExecutionContext = &#123; scopeChain: &#123; ... &#125;, variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c() a: undefined, b: undefined &#125;, this: &#123; ... &#125;&#125; 如你所见，创建阶段处理定义属性的名称，而不是为它们赋值，但正式参数（实参）除外。创建阶段完成后，执行流程进入函数内，激活/代码执行阶段在函数执行完毕后如下所示： 1234567891011121314fooExecutionContext = &#123; scopeChain: &#123; ... &#125;, variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c() a: undefined, b: undefined &#125;, this: &#123; ... &#125;&#125; 关于变量提升在掌握了关于js解释器如何创建激活对象的知识后，我们很容易解释变量，函数提升是怎么一回事。使用以下代码示例： 123456789101112131415(function() &#123; console.log(typeof foo); // function pointer console.log(typeof bar); // undefined var foo = 'hello', bar = function() &#123; return 'world' &#125; function foo() &#123; return 'hello' &#125;&#125;()); ​为什么我们可以在声明foo之前访问他​这段代码是立即执行函数，执行时创建相应执行上下文。在执行代码前即准备阶段，进行参数扫描，函数扫描，变量扫描，此时foo函数已经出现在VO中，所以可以访问。​ ​​Foo被声明两次，为什么foo显示为函数而不是未定义或字符串​接上一问，在准备阶段进行完函数扫描开始进行变量扫描，发现foo变量，但是此时VO内已经有同名的变量名，按照规则将略过。准备阶段完成，开始逐行执行代码并赋值，由于foo定义在console语句下面，所以还是输出VO中之前定义的foo，即函数。 为什么bar的值是undefined接上一问，在准备阶段进行变量扫描时发现bar，VO中没有所以bar作为属性名，值为undefined。进入执行阶段bar赋值语句在console语句下面，所以还是输出undefined。 原文链接传送：http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/","tags":[{"name":"js","slug":"js","permalink":"https://luckyjq.github.io/tags/js/"},{"name":"基础","slug":"基础","permalink":"https://luckyjq.github.io/tags/基础/"},{"name":"翻译","slug":"翻译","permalink":"https://luckyjq.github.io/tags/翻译/"}]},{"title":"个人小项目截图","date":"2019-07-24T16:00:00.000Z","path":"2019/07/25/项目图/","text":"两个简单的小项目 西电校淘小程序这个项目是在大三时候做的小程序项目，做的是校园二手平台前端页面都是自己设计，用的原生的小程序组件后端当时不怎么会，直接用的第三方的知晓云这个小程序现在还在线上。。 西电农贸小程序+管理后台当时是一个导员推荐给学校一个专卖粮油的做小程序，想法就是前一天晚上可以预定，然后第二天他直接去送就可以了页面很简单，当时学了点node，所以直接撸了一套全栈的，大概10天左右完成了，然后部署在自己的腾讯云服务器上了不过当时没注意mongodb默认是空密码的，然后之前不懂腾讯云为了方便把所有端口都开了，晾凉了，数据库被清了现在没部署在服务器上，不过有截图 小程序 h5客户端 web后台","tags":[{"name":"koa2","slug":"koa2","permalink":"https://luckyjq.github.io/tags/koa2/"},{"name":"vue","slug":"vue","permalink":"https://luckyjq.github.io/tags/vue/"},{"name":"小程序","slug":"小程序","permalink":"https://luckyjq.github.io/tags/小程序/"},{"name":"项目","slug":"项目","permalink":"https://luckyjq.github.io/tags/项目/"}]},{"title":"实现一个类似vue的双向绑定","date":"2019-07-01T16:00:00.000Z","path":"2019/07/02/实现一个类似vue的双向绑定/","text":"vue用了有段时间了，参考了github的文章，写了个简化版 github文章链接：https://github.com/DMQ/mvvm如果看不懂就看我的啊，嘿嘿嘿 前言使用Vue也有一段时间了，vue作为一个MVVM框架，最有名的就是双向绑定一般来说当数据变化时，视图层跟着变化，这是单向的当视图层变化时，数据也跟着变，这就是双向的比如在vue中通过v-model绑定的输入框，当输入框内值变化时数据也跟着变化 今天就来实现一个类似于vue的双向绑定，预期效果： 12345678910111213141516// 视图层&lt;div id=\"app\"&gt; this is &#123;&#123;name&#125;&#125;, &#123;&#123;age&#125;&#125; years old! &lt;h1&gt; &#123;&#123;name&#125;&#125; &lt;/h1&gt;&lt;/div&gt;// 数据层var vm = new MVVM(&#123; el: '#app', data: &#123; name: 'jianqi', age: 3 &#125;&#125;) Object.defineProperty的使用Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。MDN:https://dwz.cn/umKlHoaq 定义对象descriptor时注意事项： 属性描述（configurable，enumerable）：通过这个定义的属性默认不可被删除（delete obj.xxx），默认不可遍历（for in） 值描述（value， writable）：value和writable，value默认为undefined，writable默认为false值不能被改变 存取描述：get，set函数 值描述符和存取描述符不能同时存在 观察者模式Subject是一个主题（网站）。Observer相当于一个个的观察者（网民），他们可以订阅Subject，当Subject更新时通知Observer，触发Observer之前定义的回调。 1234567891011121314151617181920212223242526272829303132333435363738//es6实现class Subject &#123; constructor()&#123; this.state = 0 this.observers = [] &#125; getState() &#123; return this.state &#125; setState(state)&#123; this.state = state this.notifyAllObservers() &#125; notifyAllObservers()&#123; this.observers.forEach(observer=&gt;&#123; observer.update() &#125;) &#125; attach(observer) &#123; this.observers.push(observer) &#125;&#125;class Observer &#123; constructor(name, subject)&#123; this.name = name this.subject = subject this.subject.attach(this) &#125; update() &#123; console.log(`$&#123;this.name&#125; update,state:$&#123;this.subject.getState()&#125;`) &#125;&#125;let s = new Subject()let o = new Observer('o', s)let o2 = new Observer('o2', s)s.setState(1) 实现原理通过使用Object.defineProperty（数据拦截）和观察者模式实现双向绑定原理图： 主题是什么？ 一个个key，比如name 观察者是什么？ 视图里面的，需要被替换成数据的地方 观察者什么时候订阅？一开始执行MVVM初始化时候根据el遍历dom节点，发现时候时订阅对应主题xxxx 主题什么时候通知更新？当xxxx改变时，通知观察者更新内容。可以在一开始就监控data通过Object.defineProperty()实现 实现单向数据流（数据=&gt;视图）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139// 总入口class MVVM &#123; constructor(opts)&#123; // 初始化，绑定数据到vm对象上 this.init(opts) // 遍历所有data值，设置get和set方法 observe(this.$data) // 遍历dom树，查找&#123;&#123;&#125;&#125;的特殊标记 this.compile() &#125; init(opts)&#123; this.$el = document.querySelector(opts.el) this.$data = opts.data &#125; compile()&#123; this.traverse(this.$el) &#125; traverse(node)&#123; if(node.nodeType === 1)&#123; node.childNodes.forEach(childNode=&gt;&#123; this.traverse(childNode) &#125;) &#125; else if(node.nodeType === 3)&#123; this.renderText(node) &#125; &#125; renderText(node)&#123; let reg = /&#123;&#123;(.+?)&#125;&#125;/g let match while (match = reg.exec(node.nodeValue))&#123; let raw = match[0] let key = match[1].trim() // 初始化时绑定data里的数据到视图对应节点 node.nodeValue = node.nodeValue.replace(raw, this.$data[key]) // 对当前的key设置监听 new Observer(this, key, function (val, oldVal) &#123; node.nodeValue = node.nodeValue.replace(oldVal, val) &#125;) &#125; &#125;&#125;let currentObserver = null// 遍历data，添加监听的observe方法function observe(data) &#123; if(!data || typeof data !== 'object') return for(var key in data)&#123; //如果下面的get方法直接返回data[key]会引起循环调用导致栈溢出 let val = data[key] //每一个key都有一个自己的subject let subject = new Subject() Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function () &#123; console.log('run get') // currentObserver是一个全局的对象 if(currentObserver)&#123; // 订阅某一个subject（data中的某一个键值对的key） currentObserver.subscribeTo(subject) &#125; return val &#125;, set: function (newVal) &#123; val = newVal console.log('run set') // 更改了值，通知所有订阅者 subject.notify() &#125; &#125;) if(typeof val === 'object')&#123; observe(val) &#125; &#125;&#125;// 主题Subject，data中的每一个key都是一个subjectclass Subject &#123; constructor()&#123; // 一个主题会有多个订阅者，比如说在视图中会有多个地方有&#123;&#123;name&#125;&#125; this.observers = [] &#125; addObserver(observer)&#123; this.observers.push(observer) &#125; notify()&#123; this.observers.forEach(observer=&gt;&#123; observer.update() &#125;) &#125;&#125;// 订阅者Observerclass Observer &#123; constructor(vm, key, cb)&#123; this.vm = vm this.key = key this.cb = cb // currentObserver是一个全局的变量，设置他有值 // 并执行下一行触发get方法，会运行observe方法中的订阅操作 currentObserver = this this.value = this.getValue() currentObserver = null &#125; update()&#123; let oldVal = this.value let value = this.getValue() if(value !== oldVal)&#123; this.value = value this.cb.bind(this.vm)(value, oldVal) &#125; &#125; subscribeTo(subject)&#123; subject.addObserver(this) &#125; getValue()&#123; // 这里会触发data中元素的get函数 let value = this.vm.$data[this.key] return value &#125;&#125;` 1234567891011121314// 调用&lt;div id=\"app\"&gt; this is &#123;&#123;name&#125;&#125;, &#123;&#123;age&#125;&#125; years old!&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new MVVM(&#123; el: '#app', data: &#123; name: 'jianqi', age: 3 &#125; &#125;)&lt;/script&gt; 实现双向绑定在vue中，如果要对一个input框进行双向绑定，需要设置v-model指令这里我们进行相同的设置，对于设置了v-model的input实现双向绑定在前面已经实现单向数据流的基础上很容易实现双向绑定在解析dom时候检测v-model指令，对应的元素绑定监听事件，当值改变时触发设置data即可 12345678910111213141516171819202122232425262728293031323334353637// 修改上面代码的MVVMclass MVVM &#123; // ...... traverse(node)&#123; if(node.nodeType === 1)&#123; this.compileNode(node) node.childNodes.forEach(childNode=&gt;&#123; this.traverse(childNode) &#125;) &#125; else if(node.nodeType === 3)&#123; this.renderText(node) &#125; &#125; // ...... compileNode(node)&#123; let attrs = [...node.attributes] attrs.forEach(attr=&gt;&#123; if(this.isDirective(attr.name))&#123; let key = attr.value node.value = this.$data[key] new Observer(this, key, function (newVal) &#123; node.value = newVal &#125;) node.oninput = (e)=&gt;&#123; this.$data[key] = e.target.value &#125; &#125; &#125;) &#125; isDirective(attrName)&#123; return attrName === 'v-model' &#125;&#125;` 调用 123456789101112131415161718// 调用&lt;div id=\"app\"&gt; this is &#123;&#123;name&#125;&#125;, &#123;&#123;age&#125;&#125; years old! &lt;h1&gt; &#123;&#123;name&#125;&#125; &lt;/h1&gt; &lt;input type=\"text\" v-model=\"name\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new MVVM(&#123; el: '#app', data: &#123; name: 'jianqi', age: 3 &#125; &#125;)&lt;/script&gt; 优化","tags":[{"name":"vue","slug":"vue","permalink":"https://luckyjq.github.io/tags/vue/"},{"name":"源码","slug":"源码","permalink":"https://luckyjq.github.io/tags/源码/"}]},{"title":"koa2入门","date":"2019-06-28T16:00:00.000Z","path":"2019/06/29/koa2入门/","text":"大杂烩，记录贴。包含一个简版koa框架的核心实现 前置知识：关于async和await的理解https://segmentfault.com/a/1190000007535316 await必须包裹在async函数里 async函数执行返回的是一个promise对象 await在等什么？等一个promise，获取他的resolve的值 如果await后面的promise返回的是reject的值，那么需要使用try，catch进行包裹 koa2原理（use和next）源码解读：https://zhuanlan.zhihu.com/p/34797505 自己实现一个简版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const http = require('http')// 组合中间件function compose(middlewareList) &#123; return function (ctx) &#123; //dispatch函数用于执行一个中间件 function dispatch(i) &#123; const fn = middlewareList[i] try &#123; return Promise.resolve( //这里fn的第二个参数就相当于next fn(ctx, dispatch.bind(null, i + 1)) // promise ) &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; return dispatch(0) &#125;&#125;class LikeKoa2 &#123; constructor() &#123; this.middlewareList = [] &#125; use(fn) &#123; this.middlewareList.push(fn) return this &#125; createContext(req, res) &#123; const ctx = &#123; req, res &#125; ctx.query = req.query return ctx &#125; handleRequest(ctx, fn) &#123; return fn(ctx) &#125; callback() &#123; const fn = compose(this.middlewareList) return (req, res) =&gt; &#123; const ctx = this.createContext(req, res) return this.handleRequest(ctx, fn) &#125; &#125; listen(...args) &#123; const server = http.createServer(this.callback()) server.listen(...args) &#125;&#125;module.exports = LikeKoa2 koa2的ctx对象koa2的ctx封装了req和res，可以通过ctx直接取得，也可以通过ctx.request.xx的形式取得常用的： ctx.params ctx.request.query ctx.request.header ctx.request.body( 需要使用body-parser插件) 利用cookie和session进行鉴权作为一个网站有些资源需要登陆才能访问，有些不登陆也可以浏览。如何实现鉴权？常用的方法是cookie和session 这里假设session存储在服务端内存中，是一个数组SESSION[ ] 用户访问某个url时，进行用户鉴权，有无cookie 没有cookie，响应设置cookie,比如userid: xxx01，在服务端SESSION[ ]中添加一个session{xxx01:{ }} 用户登陆，往SESSION中对应的session对象中写字段，比如username: xxx。此时SESSON数组中有一个session应该是这样的：ssession{xxx01:{username: xxx}} 请求时携带cookie，服务端获取userid去SESSION中进行查询，看username是否有值，判断是否登陆了 注意事项： 设置 cookie时应当设置过期时间 session存储在服务器中重启就没了，需要进行持久化。可以考虑存在redis中或者直接加密后返回到cookie也可以 koa2常用插件登陆鉴权相关 koa-session（把session加密后存在cookie中，支持外部数据库）源码解读文章：https://segmentfault.com/a/1190000012412299 koa-generic-session，koa-redis（这两个配套可以存储session到redis） Sequelize，操作mysql数据库（如果链接mysql需要安装mysql2驱动） 异常处理js中try catch只能捕捉同步错误异步代码的错误很难，通过使用promise和async和await可以简化异步的错误处理，使用try和catch下面这样也是没用的，必须返回异步函数的promise包装 这样才对 AOP思想自定义全局异常处理函数，最先注册，try next()即可，相当于调用链条 封装错误对象状态码error codeerror messagerequest url 开发环境和生产环境的异常配置开发环境下全局的非httpError捕捉需要再抛出去，方便开发时候调试生产环境就不要抛了 一个作业题 123456789101112131415161718192021222324class A &#123; constructor() &#123; this.nameA = 'a' this.nameD = 'd' &#125; validateA() &#123; console.log(\"A\") &#125;&#125;class B extends A &#123; constructor() &#123; super() this.nameB = 'b' &#125; validateB() &#123; console.log(\"B\") &#125;&#125;var b = new B()// 编写一个函数findMembers,获取b的所有带前缀的属性和方法const members = findMembers2(b, 'name', 'validate')","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://luckyjq.github.io/tags/nodejs/"},{"name":"koa2","slug":"koa2","permalink":"https://luckyjq.github.io/tags/koa2/"}]},{"title":"使用nodejs原生http开发api接口","date":"2019-06-24T04:31:41.808Z","path":"2019/06/24/nodejs/","text":"总体架构 开发环境搭建使用webstorm进行开发，新建项目，发现没有nodejs智能提示安装node智能提示 通过npm init新建项目两个好用的插件：全局安装nodemon，支持热重载项目安装cross-env，兼容操作系统 配置package.json的script选项配置中的NODE_ENV=dev，当以npm run dev启动时，process.env.NODE_ENV的值就为dev 12\"dev\": \"cross-env NODE_ENV=dev nodemon ./bin/www.js\",\"prd\": \"cross-env NODE_ENV=production nodemon ./bin/www.js\" 设计接口 响应结构设计123456789101112//成功&#123; errno: 0, data: &#123;&#125;, message: ''&#125;//失败&#123; errno: -1, message: ''&#125; 通过es6的class新建响应模型 12345678910111213141516171819202122232425262728293031323334class BaseModel &#123; constructor(data, message) &#123; if(typeof data === 'string')&#123; this.message = data data = null message = null &#125; if(data) &#123; this.data = data &#125; if(message)&#123; this.message = message &#125; &#125;&#125;class SuccessModel extends BaseModel &#123; constructor(data, message)&#123; super(data, message) this.errno = 0 &#125;&#125;class ErrorModel extends BaseModel &#123; constructor(data, message)&#123; super(data, message) this.errno = -1&#125;&#125;module.exports = &#123; SuccessModel, ErrorModel&#125; 项目结构拆分将启动服务器封装成www.js，外部传入服务器响应函数响应函数在app.js中进行定义，函数中都可以引用req，res对象对路由进行拆分，博客路由和用户路由，在app.js中进行引用app.js中引用路由对所有请求拦截处理，有对应路由返回数据否则返回404新建controller文件夹，主要用于操作数据，然后在router中引用对应controller中的方法router中调用controller方法获得数据，封装成响应model并返回数据新增配置文件，配置mysql和redis链接信息封装mysql链接工具，封装执行sql函数 对promise的一些疑惑碰到的一些小bugsql语句定义的不规范，${username}应该要加上引号 1const sql = `select username, realname from user where username=$&#123;username&#125; and password=$&#123;password&#125;` 日志系统1.访问日志2.自定义日志，包括自定义事件，错误记录等 通过流对象写日志日志的拆分，按照天等（通常用linux的定时任务crontab） sql注入的d防范使用mysql的escape函数，所有的字段先用escape转义然后dadaw${xxx}中的${xx}就不用加引号了 npm xss模块","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://luckyjq.github.io/tags/nodejs/"}]},{"title":"使用七牛云一键上传博客图片（mac）","date":"2019-06-23T16:00:00.000Z","path":"2019/06/24/使用七牛云一键上传博客图片（mac)/","text":"嘀～小姐姐秒上传到七牛云啦！ 写博客的效率又提升了！ 随便BBhexo的博客很早之前就搭建了，零零散散写过几篇文章。现在大学生活也结束了，即将步入研究生，打算好好利用这个暑假。重新拾起博客，当作一个记录的小地方。 之前我很讨厌在hexo上写博客，因为图片配置是在是太麻烦了，首先得准备好博客的照片，然后上传到某一个图传，再拿到图片地址按照特定格式插入文章。这倒也还好，关键是那些免费图床老是容易挂。。。好不容易申请了七牛云，竟然需要给空间绑定域名，测试域名只能用一个月，蛋疼。 终于。。我申请好了独立域名，通过了备案，有了足够的时间和热情。。我又回坑了。 实现原理Alfred是个什么我也没仔细研究，大概就是一个效率工具，最🐂的地方是它支持自定义脚本，然后实现自动化操作。所以我们就是要利用这个工具和七牛的开放SDK完成一个自动化操作。 当然。。有人已经写好了这个自动化脚本了项目地址：https://github.com/jiwenxing/qimage-mac 正式开干1.下载Alfred，需要使用他的收费功能，下面会给出破解版。下载地址：https://pan.baidu.com/s/1mir5F6K提取码：jj7s 2.安装七牛云的SDK工具下载地址：https://developer.qiniu.com/kodo/tools/1302/qshell下载完后解压，把qshell_darwin_amd64文件重命名为qshell并移至usr/local/bin目录下即可。后面的脚本会引用这个SDK。 3.注册七牛云账号并实名认证自己去注册。最好再准备一个独立域名，因为七牛的测试域名有效期只有一个月。 4.下载github脚本，运行qimage.alfredworkflow 修改中间的 Run Script，具体操作见下面链接。https://github.com/jiwenxing/qimage-mac/issues/16 修改Hotkey进行自动化触发快捷键设置，推荐cmd+option+v。 现在你可以试一试了，cmd+c复制一张图片到剪切板，在md文件里cmd+option+v😯 他返回了md的图片引用格式，写博客效率又提升了呢！ 当然你可能会需要一些定制化的小变化，这时候你就要稍微读一下脚本然后进行修改了。 传个小姐姐试试水！ 喂！小妹妹！你跟谁撒娇呢！","tags":[{"name":"工具","slug":"工具","permalink":"https://luckyjq.github.io/tags/工具/"},{"name":"骚操作","slug":"骚操作","permalink":"https://luckyjq.github.io/tags/骚操作/"}]},{"title":"浏览器和nodejs的事件循环机制","date":"2019-04-20T16:00:00.000Z","path":"2019/04/21/浏览器和nodejs的事件循环机制/","text":"事件循环，画个圈圈…… 浏览器的事件循环机制浏览器事件循环图（摘自《javascript忍者秘籍第二版》13章）： 宏任务微任务宏任务：从浏览器角度，代表一个离散的，独立的工作单元比如：创建主文档对象，解析HTML，执行主线（全局）js代码更改当前URL和各种事件（页面加载，网络事件，定时器等） 微任务：是更小的任务，微任务要尽可能快的，通过异步方式执行比如：DOM变化（MutationObserver），Promise回调函数由于因为async await 本身就是promise+generator的语法糖，所以await后面的也是 从面试题理解运行机制123456789101112// 写出输出setTimeout(function () &#123; console.log(1);&#125;);new Promise(function(resolve,reject)&#123; console.log(2) resolve(3)&#125;).then(function(val)&#123; console.log(val);&#125;)console.log(4); 上面的代码执行结果为：2，4，3，1我们结合上面的事件循环图来理解下输出结果 首先执行主线（全局js代码），碰到定时器代码，定时器时间为0表示尽快执行定时器是宏任务，于是把定时器任务放入宏任务队列现在宏任务队列中是（主线，定时器） 接着往下解析，开始执行promise的代码，遇到promise里的2直接输出 promise中有一个异步方法，是微任务，于是把他放到微任务队列 继续往下执行全局代码，输出4 跑完上面的流程，js主线（全局）代码执行完成，同时也是第一个宏任务执行完成了 按照事件循环图的流程，开始检查微任务队列是否有任务，有的话执行所有微任务，输出3 第一轮循环结束，更新UI主线（全局）任务从宏任务中出队 开始新的一轮事件循环，执行队首的宏任务即之前的定时器任务输出1 通过上面的例子我们也可以知道，定时器的执行时间机制：因为js单线程的本质，我们只能控制定时器何时被加入宏任务队列，而无法控制其何时执行 再看一个例子： 1234567891011121314151617181920212223242526272829303132333435363738//请写出输出内容async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; console.log('async2');&#125;console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end');/*script startasync1 startasync2promise1script endasync1 endpromise2setTimeout*/ 上面这个例题可能会有一些地方难理解，主要是async和await 12345async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125; 等价于： 123456async function async1() &#123; console.log('async1 start'); Promise.resolve(async2()).then(() =&gt; &#123; console.log('async1 end'); &#125;)&#125; nodejs的事件循环机制","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://luckyjq.github.io/tags/nodejs/"},{"name":"js","slug":"js","permalink":"https://luckyjq.github.io/tags/js/"},{"name":"基础","slug":"基础","permalink":"https://luckyjq.github.io/tags/基础/"}]},{"title":"理解typeof和instanceof","date":"2019-04-17T09:34:32.000Z","path":"2019/04/17/理解typeof和instanceof/","text":"理解typeof和instanceof，从原型开始说起 typeof判断类型存在的问题对于这两个js关键词，一直停留在很浅显的理解上。直到最近开始刷个大公司的面试题，发现这一知识点出场之高，决心总结一下。 typeof判断类型，截图来自MDN。问题出现了，当类型为Null和Array和Object时候，均返回“object”，如何区别？ 一种常用的检测方法是使用：Object.prototype.toString.call(obj) 12var arr = [12,'aaa']Object.prototype.toString.call(arr) //\"[object Array]\" 为什么要使用Object原型上的toString方法，而不是直接调用？因为Array ，function等类型作为Object的实例，都重写了toString方法 1arr.toString() //\"12,aaa\" 但是使用上面这种方法判断也存在局限性，对于任何对象，返回都是相同的。我们现在的需求是有不同构造函数比如Student，Dog等等，我们new一个实例的时候想判断这个实例是一个Dog还是一个Student，这时候就需要用到instanceof。 instanceof大法好123456789var Student = function (name,age) &#123;this.name = namethis.age = age&#125;Student.prototype.say = function()&#123;console.log(`i am $&#123;name&#125;,and i am $&#123;age&#125; years old!`)&#125;var stu = new Student('Tom', 20)stu instanceof Student //true 要理解instanceof肯定逃不过原型链，祭出原型链大图（如果还不理解原型链可以参考其他文章，要求能把下面图看懂） 关键点：首先，js中一切都是对象，函数也是对象所有的函数都有prototype和proto属性所有的对象都有proto属性Object.prototype是所有对象的根Function.prototype是所有函数的根Object和Function都是构造函数 instanceof的判断原理很简单，就是在实例的proto链条上寻找，如果有就返回true通过上面的图也可以理解几个很奇怪的instanceof判断 1234Function instanceof Function //trueObject instanceof Function //trueObject instanceof Object //trueFunction instanceof Object //true 补充这两天看书，发现自己对instanceof的使用有个地方还是不清楚 12345function Person()&#123;&#125;Person.prototype.dance = function()&#123;&#125;function Ninja()&#123;&#125;Ninja.prototype = new Person()const ninja = new Ninja() 一般的js继承写法，一开始我想的是：Ninja.prototype被改写成一个Person实例对象了所以:ninja instanceof Ninja返回false，ninja instanceof Person 返回true 但是测试返回的是两个true 到底该如何理解instanceof?检查右边的函数原型是否存在于操作符左边的对象的原型链上Ninja.prototype 是否在ninja对象的proto链上 当你实例化时候，const ninja = new Ninja()判断ninja instanceof Ninja时，就看Ninja.prototype是否在ninja实例的proto链条上而Ninja.prototype是new Person，在ninja实例的proto链条上，所以就返回true这样才是正确理解instanceof的方式","tags":[{"name":"js","slug":"js","permalink":"https://luckyjq.github.io/tags/js/"},{"name":"基础","slug":"基础","permalink":"https://luckyjq.github.io/tags/基础/"}]}]