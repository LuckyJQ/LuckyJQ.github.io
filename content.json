[{"title":"使用nodejs原生http开发api接口","date":"2019-06-24T04:31:41.808Z","path":"2019/06/24/nodejs/","text":"总体架构 开发环境搭建使用webstorm进行开发，新建项目，发现没有nodejs智能提示安装node智能提示 通过npm init新建项目两个好用的插件：全局安装nodemon，支持热重载项目安装cross-env，兼容操作系统 配置package.json的script选项配置中的NODE_ENV=dev，当以npm run dev启动时，process.env.NODE_ENV的值就为dev 12\"dev\": \"cross-env NODE_ENV=dev nodemon ./bin/www.js\",\"prd\": \"cross-env NODE_ENV=production nodemon ./bin/www.js\" 设计接口 响应结构设计123456789101112//成功&#123; errno: 0, data: &#123;&#125;, message: ''&#125;//失败&#123; errno: -1, message: ''&#125; 通过es6的class新建响应模型 12345678910111213141516171819202122232425262728293031323334class BaseModel &#123; constructor(data, message) &#123; if(typeof data === 'string')&#123; this.message = data data = null message = null &#125; if(data) &#123; this.data = data &#125; if(message)&#123; this.message = message &#125; &#125;&#125;class SuccessModel extends BaseModel &#123; constructor(data, message)&#123; super(data, message) this.errno = 0 &#125;&#125;class ErrorModel extends BaseModel &#123; constructor(data, message)&#123; super(data, message) this.errno = -1&#125;&#125;module.exports = &#123; SuccessModel, ErrorModel&#125; 项目结构拆分将启动服务器封装成www.js，外部传入服务器响应函数响应函数在app.js中进行定义，函数中都可以引用req，res对象对路由进行拆分，博客路由和用户路由，在app.js中进行引用app.js中引用路由对所有请求拦截处理，有对应路由返回数据否则返回404新建controller文件夹，主要用于操作数据，然后在router中引用对应controller中的方法router中调用controller方法获得数据，封装成响应model并返回数据新增配置文件，配置mysql和redis链接信息封装mysql链接工具，封装执行sql函数 对promise的一些疑惑碰到的一些小bugsql语句定义的不规范，${username}应该要加上引号 1const sql = `select username, realname from user where username=$&#123;username&#125; and password=$&#123;password&#125;` 日志系统1.访问日志2.自定义日志，包括自定义事件，错误记录等 通过流对象写日志日志的拆分，按照天等（通常用linux的定时任务crontab） sql注入的d防范使用mysql的escape函数，所有的字段先用escape转义然后dadaw${xxx}中的${xx}就不用加引号了 npm xss模块","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://luckyjq.github.io/tags/nodejs/"}]},{"title":"理解typeof和instanceof","date":"2019-06-24T04:31:41.808Z","path":"2019/06/24/理解typeof和instanceof/","text":"typeof判断类型存在的问题对于这两个js关键词，一直停留在很浅显的理解上。直到最近开始刷个大公司的面试题，发现这一知识点出场之高，决心总结一下。 typeof判断类型，截图来自MDN。问题出现了，当类型为Null和Array和Object时候，均返回“object”，如何区别？ 一种常用的检测方法是使用：Object.prototype.toString.call(obj) 12var arr = [12,'aaa']Object.prototype.toString.call(arr) //\"[object Array]\" 为什么要使用Object原型上的toString方法，而不是直接调用？因为Array ，function等类型作为Object的实例，都重写了toString方法 1arr.toString() //\"12,aaa\" 但是使用上面这种方法判断也存在局限性，对于任何对象，返回都是相同的。我们现在的需求是有不同构造函数比如Student，Dog等等，我们new一个实例的时候想判断这个实例是一个Dog还是一个Student，这时候就需要用到instanceof。 instanceofd大法好123456789var Student = function (name,age) &#123;this.name = namethis.age = age&#125;Student.prototype.say = function()&#123;console.log(`i am $&#123;name&#125;,and i am $&#123;age&#125; years old!`)&#125;var stu = new Student('Tom', 20)stu instanceof Student //true 要理解instanceof肯定逃不过原型链，祭出原型链大图（如果还不理解原型链可以参考其他文章，要求能把下面图看懂） 关键点：首先，js中一切都是对象，函数也是对象所有的函数都有prototype和proto属性所有的对象都有proto属性Object.prototype是所有对象的根Function.prototype是所有函数的根Object和Function都是构造函数 instanceof的判断原理很简单，就是在实例的proto链条上寻找，如果有就返回true通过上面的图也可以理解几个很奇怪的instanceof判断 1234Function instanceof Function //trueObject instanceof Function //trueObject instanceof Object //trueFunction instanceof Object //true 补充这两天看书，发现自己对instanceof的使用有个地方还是不清楚 12345function Person()&#123;&#125;Person.prototype.dance = function()&#123;&#125;function Ninja()&#123;&#125;Ninja.prototype = new Person()const ninja = new Ninja() 一般的js继承写法，一开始我想的是：Ninja.prototype被改写成一个Person实例对象了所以:ninja instanceof Ninja返回false，ninja instanceof Person 返回true 但是测试返回的是两个true 到底该如何理解instanceof?检查右边的函数原型是否存在于操作符左边的对象的原型链上Ninja.prototype 是否在ninja对象的proto链上 当你实例化时候，const ninja = new Ninja()判断ninja instanceof Ninja时，就看Ninja.prototype是否在ninja实例的proto链条上而Ninja.prototype是new Person，在ninja实例的proto链条上，所以就返回true这样才是正确理解instanceof的方式","tags":[{"name":"js","slug":"js","permalink":"https://luckyjq.github.io/tags/js/"},{"name":"基础","slug":"基础","permalink":"https://luckyjq.github.io/tags/基础/"}]},{"title":"github博客绑定腾讯云二级域名","date":"2019-06-24T04:31:41.808Z","path":"2019/06/24/二级域名/","text":"绑定说明","tags":[{"name":"建站","slug":"建站","permalink":"https://luckyjq.github.io/tags/建站/"}]},{"title":"使用七牛云一键上传博客图片（mac）","date":"2019-06-24T04:31:41.808Z","path":"2019/06/24/test1/","text":"嘀～小姐姐秒上传到七牛云啦！ 写博客的效率又提升了！ 随便BBhexo的博客很早之前就搭建了，零零散散写过几篇文章。现在大学生活也结束了，即将步入研究生，打算好好利用这个暑假。重新拾起博客，当作一个记录的小地方。 之前我很讨厌在hexo上写博客，因为图片配置是在是太麻烦了，首先得准备好博客的照片，然后上传到某一个图传，再拿到图片地址按照特定格式插入文章。这倒也还好，关键是那些免费图床老是容易挂。。。好不容易申请了七牛云，竟然需要给空间绑定域名，测试域名只能用一个月，蛋疼。 终于。。我申请好了独立域名，通过了备案，有了足够的时间和热情。。我又回坑了。 实现原理Alfred是个什么我也没仔细研究，大概就是一个效率工具，最🐂的地方是它支持自定义脚本，然后实现自动化操作。所以我们就是要利用这个工具和七牛的开放SDK完成一个自动化操作。 当然。。有人已经写好了这个自动化脚本了项目地址：https://github.com/jiwenxing/qimage-mac 正式开干1.下载Alfred，需要使用他的收费功能，下面会给出破解版。下载地址：https://pan.baidu.com/s/1mir5F6K提取码：jj7s 2.安装七牛云的SDK工具下载地址：https://developer.qiniu.com/kodo/tools/1302/qshell下载完后解压，把qshell_darwin_amd64文件重命名为qshell并移至usr/local/bin目录下即可。后面的脚本会引用这个SDK。 3.注册七牛云账号并实名认证自己去注册。最好再准备一个独立域名，因为七牛的测试域名有效期只有一个月。 4.下载github脚本，运行qimage.alfredworkflow 修改中间的 Run Script，具体操作见下面链接。https://github.com/jiwenxing/qimage-mac/issues/16 修改Hotkey进行自动化触发快捷键设置，推荐cmd+option+v。 现在你可以试一试了，cmd+c复制一张图片到剪切板，在md文件里cmd+option+v😯 他返回了md的图片引用格式，写博客效率又提升了呢！ 当然你可能会需要一些定制化的小变化，这时候你就要稍微读一下脚本然后进行修改了。 传个小姐姐试试水！ 喂！小妹妹！你跟谁撒娇呢！","tags":[{"name":"工具","slug":"工具","permalink":"https://luckyjq.github.io/tags/工具/"},{"name":"骚操作","slug":"骚操作","permalink":"https://luckyjq.github.io/tags/骚操作/"}]}]