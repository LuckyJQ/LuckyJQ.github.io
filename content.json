[{"title":"个人小项目截图","date":"2019-07-24T16:00:00.000Z","path":"2019/07/25/项目图/","text":"两个简单的小项目 西电校淘小程序这个项目是在大三时候做的小程序项目，做的是校园二手平台前端页面都是自己设计，用的原生的小程序组件后端当时不怎么会，直接用的第三方的知晓云这个小程序现在还在线上。。 西电农贸小程序+管理后台当时是一个导员推荐给学校一个专卖粮油的做小程序，想法就是前一天晚上可以预定，然后第二天他直接去送就可以了页面很简单，当时学了点node，所以直接撸了一套全栈的，大概10天左右完成了，然后部署在自己的腾讯云服务器上了不过当时没注意mongodb默认是空密码的，然后之前不懂腾讯云为了方便把所有端口都开了，晾凉了，数据库被清了现在没部署在服务器上，不过有截图 小程序 h5客户端 web后台","tags":[{"name":"koa2","slug":"koa2","permalink":"https://luckyjq.github.io/tags/koa2/"},{"name":"vue","slug":"vue","permalink":"https://luckyjq.github.io/tags/vue/"},{"name":"小程序","slug":"小程序","permalink":"https://luckyjq.github.io/tags/小程序/"},{"name":"项目","slug":"项目","permalink":"https://luckyjq.github.io/tags/项目/"}]},{"title":"实现一个类似vue的双向绑定","date":"2019-07-01T16:00:00.000Z","path":"2019/07/02/实现一个类似vue的双向绑定/","text":"vue用了有段时间了，参考了github的文章，写了个简化版 github文章链接：https://github.com/DMQ/mvvm如果看不懂就看我的啊，嘿嘿嘿 前言使用Vue也有一段时间了，vue作为一个MVVM框架，最有名的就是双向绑定一般来说当数据变化时，视图层跟着变化，这是单向的当视图层变化时，数据也跟着变，这就是双向的比如在vue中通过v-model绑定的输入框，当输入框内值变化时数据也跟着变化 今天就来实现一个类似于vue的双向绑定，预期效果： 12345678910111213141516// 视图层&lt;div id=\"app\"&gt; this is &#123;&#123;name&#125;&#125;, &#123;&#123;age&#125;&#125; years old! &lt;h1&gt; &#123;&#123;name&#125;&#125; &lt;/h1&gt;&lt;/div&gt;// 数据层var vm = new MVVM(&#123; el: '#app', data: &#123; name: 'jianqi', age: 3 &#125;&#125;) Object.defineProperty的使用Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。MDN:https://dwz.cn/umKlHoaq 定义对象descriptor时注意事项： 属性描述（configurable，enumerable）：通过这个定义的属性默认不可被删除（delete obj.xxx），默认不可遍历（for in） 值描述（value， writable）：value和writable，value默认为undefined，writable默认为false值不能被改变 存取描述：get，set函数 值描述符和存取描述符不能同时存在 观察者模式Subject是一个主题（网站）。Observer相当于一个个的观察者（网民），他们可以订阅Subject，当Subject更新时通知Observer，触发Observer之前定义的回调。 1234567891011121314151617181920212223242526272829303132333435363738//es6实现class Subject &#123; constructor()&#123; this.state = 0 this.observers = [] &#125; getState() &#123; return this.state &#125; setState(state)&#123; this.state = state this.notifyAllObservers() &#125; notifyAllObservers()&#123; this.observers.forEach(observer=&gt;&#123; observer.update() &#125;) &#125; attach(observer) &#123; this.observers.push(observer) &#125;&#125;class Observer &#123; constructor(name, subject)&#123; this.name = name this.subject = subject this.subject.attach(this) &#125; update() &#123; console.log(`$&#123;this.name&#125; update,state:$&#123;this.subject.getState()&#125;`) &#125;&#125;let s = new Subject()let o = new Observer('o', s)let o2 = new Observer('o2', s)s.setState(1) 实现原理通过使用Object.defineProperty（数据拦截）和观察者模式实现双向绑定原理图： 主题是什么？ 一个个key，比如name 观察者是什么？ 视图里面的，需要被替换成数据的地方 观察者什么时候订阅？一开始执行MVVM初始化时候根据el遍历dom节点，发现时候时订阅对应主题xxxx 主题什么时候通知更新？当xxxx改变时，通知观察者更新内容。可以在一开始就监控data通过Object.defineProperty()实现 实现单向数据流（数据=&gt;视图）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139// 总入口class MVVM &#123; constructor(opts)&#123; // 初始化，绑定数据到vm对象上 this.init(opts) // 遍历所有data值，设置get和set方法 observe(this.$data) // 遍历dom树，查找&#123;&#123;&#125;&#125;的特殊标记 this.compile() &#125; init(opts)&#123; this.$el = document.querySelector(opts.el) this.$data = opts.data &#125; compile()&#123; this.traverse(this.$el) &#125; traverse(node)&#123; if(node.nodeType === 1)&#123; node.childNodes.forEach(childNode=&gt;&#123; this.traverse(childNode) &#125;) &#125; else if(node.nodeType === 3)&#123; this.renderText(node) &#125; &#125; renderText(node)&#123; let reg = /&#123;&#123;(.+?)&#125;&#125;/g let match while (match = reg.exec(node.nodeValue))&#123; let raw = match[0] let key = match[1].trim() // 初始化时绑定data里的数据到视图对应节点 node.nodeValue = node.nodeValue.replace(raw, this.$data[key]) // 对当前的key设置监听 new Observer(this, key, function (val, oldVal) &#123; node.nodeValue = node.nodeValue.replace(oldVal, val) &#125;) &#125; &#125;&#125;let currentObserver = null// 遍历data，添加监听的observe方法function observe(data) &#123; if(!data || typeof data !== 'object') return for(var key in data)&#123; //如果下面的get方法直接返回data[key]会引起循环调用导致栈溢出 let val = data[key] //每一个key都有一个自己的subject let subject = new Subject() Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function () &#123; console.log('run get') // currentObserver是一个全局的对象 if(currentObserver)&#123; // 订阅某一个subject（data中的某一个键值对的key） currentObserver.subscribeTo(subject) &#125; return val &#125;, set: function (newVal) &#123; val = newVal console.log('run set') // 更改了值，通知所有订阅者 subject.notify() &#125; &#125;) if(typeof val === 'object')&#123; observe(val) &#125; &#125;&#125;// 主题Subject，data中的每一个key都是一个subjectclass Subject &#123; constructor()&#123; // 一个主题会有多个订阅者，比如说在视图中会有多个地方有&#123;&#123;name&#125;&#125; this.observers = [] &#125; addObserver(observer)&#123; this.observers.push(observer) &#125; notify()&#123; this.observers.forEach(observer=&gt;&#123; observer.update() &#125;) &#125;&#125;// 订阅者Observerclass Observer &#123; constructor(vm, key, cb)&#123; this.vm = vm this.key = key this.cb = cb // currentObserver是一个全局的变量，设置他有值 // 并执行下一行触发get方法，会运行observe方法中的订阅操作 currentObserver = this this.value = this.getValue() currentObserver = null &#125; update()&#123; let oldVal = this.value let value = this.getValue() if(value !== oldVal)&#123; this.value = value this.cb.bind(this.vm)(value, oldVal) &#125; &#125; subscribeTo(subject)&#123; subject.addObserver(this) &#125; getValue()&#123; // 这里会触发data中元素的get函数 let value = this.vm.$data[this.key] return value &#125;&#125;` 1234567891011121314// 调用&lt;div id=\"app\"&gt; this is &#123;&#123;name&#125;&#125;, &#123;&#123;age&#125;&#125; years old!&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new MVVM(&#123; el: '#app', data: &#123; name: 'jianqi', age: 3 &#125; &#125;)&lt;/script&gt; 实现双向绑定在vue中，如果要对一个input框进行双向绑定，需要设置v-model指令这里我们进行相同的设置，对于设置了v-model的input实现双向绑定在前面已经实现单向数据流的基础上很容易实现双向绑定在解析dom时候检测v-model指令，对应的元素绑定监听事件，当值改变时触发设置data即可 12345678910111213141516171819202122232425262728293031323334353637// 修改上面代码的MVVMclass MVVM &#123; // ...... traverse(node)&#123; if(node.nodeType === 1)&#123; this.compileNode(node) node.childNodes.forEach(childNode=&gt;&#123; this.traverse(childNode) &#125;) &#125; else if(node.nodeType === 3)&#123; this.renderText(node) &#125; &#125; // ...... compileNode(node)&#123; let attrs = [...node.attributes] attrs.forEach(attr=&gt;&#123; if(this.isDirective(attr.name))&#123; let key = attr.value node.value = this.$data[key] new Observer(this, key, function (newVal) &#123; node.value = newVal &#125;) node.oninput = (e)=&gt;&#123; this.$data[key] = e.target.value &#125; &#125; &#125;) &#125; isDirective(attrName)&#123; return attrName === 'v-model' &#125;&#125;` 调用 123456789101112131415161718// 调用&lt;div id=\"app\"&gt; this is &#123;&#123;name&#125;&#125;, &#123;&#123;age&#125;&#125; years old! &lt;h1&gt; &#123;&#123;name&#125;&#125; &lt;/h1&gt; &lt;input type=\"text\" v-model=\"name\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new MVVM(&#123; el: '#app', data: &#123; name: 'jianqi', age: 3 &#125; &#125;)&lt;/script&gt; 优化","tags":[{"name":"vue","slug":"vue","permalink":"https://luckyjq.github.io/tags/vue/"},{"name":"源码","slug":"源码","permalink":"https://luckyjq.github.io/tags/源码/"}]},{"title":"koa2入门","date":"2019-06-28T16:00:00.000Z","path":"2019/06/29/koa2入门/","text":"大杂烩，记录贴。包含一个简版koa框架的核心实现 前置知识：关于async和await的理解https://segmentfault.com/a/1190000007535316 await必须包裹在async函数里 async函数执行返回的是一个promise对象 await在等什么？等一个promise，获取他的resolve的值 如果await后面的promise返回的是reject的值，那么需要使用try，catch进行包裹 koa2原理（use和next）源码解读：https://zhuanlan.zhihu.com/p/34797505 自己实现一个简版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const http = require('http')// 组合中间件function compose(middlewareList) &#123; return function (ctx) &#123; //dispatch函数用于执行一个中间件 function dispatch(i) &#123; const fn = middlewareList[i] try &#123; return Promise.resolve( //这里fn的第二个参数就相当于next fn(ctx, dispatch.bind(null, i + 1)) // promise ) &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; return dispatch(0) &#125;&#125;class LikeKoa2 &#123; constructor() &#123; this.middlewareList = [] &#125; use(fn) &#123; this.middlewareList.push(fn) return this &#125; createContext(req, res) &#123; const ctx = &#123; req, res &#125; ctx.query = req.query return ctx &#125; handleRequest(ctx, fn) &#123; return fn(ctx) &#125; callback() &#123; const fn = compose(this.middlewareList) return (req, res) =&gt; &#123; const ctx = this.createContext(req, res) return this.handleRequest(ctx, fn) &#125; &#125; listen(...args) &#123; const server = http.createServer(this.callback()) server.listen(...args) &#125;&#125;module.exports = LikeKoa2 koa2的ctx对象koa2的ctx封装了req和res，可以通过ctx直接取得，也可以通过ctx.request.xx的形式取得常用的： ctx.params ctx.request.query ctx.request.header ctx.request.body( 需要使用body-parser插件) 利用cookie和session进行鉴权作为一个网站有些资源需要登陆才能访问，有些不登陆也可以浏览。如何实现鉴权？常用的方法是cookie和session 这里假设session存储在服务端内存中，是一个数组SESSION[ ] 用户访问某个url时，进行用户鉴权，有无cookie 没有cookie，响应设置cookie,比如userid: xxx01，在服务端SESSION[ ]中添加一个session{xxx01:{ }} 用户登陆，往SESSION中对应的session对象中写字段，比如username: xxx。此时SESSON数组中有一个session应该是这样的：ssession{xxx01:{username: xxx}} 请求时携带cookie，服务端获取userid去SESSION中进行查询，看username是否有值，判断是否登陆了 注意事项： 设置 cookie时应当设置过期时间 session存储在服务器中重启就没了，需要进行持久化。可以考虑存在redis中或者直接加密后返回到cookie也可以 koa2常用插件登陆鉴权相关 koa-session（把session加密后存在cookie中，支持外部数据库）源码解读文章：https://segmentfault.com/a/1190000012412299 koa-generic-session，koa-redis（这两个配套可以存储session到redis） Sequelize，操作mysql数据库（如果链接mysql需要安装mysql2驱动） 异常处理js中try catch只能捕捉同步错误异步代码的错误很难，通过使用promise和async和await可以简化异步的错误处理，使用try和catch下面这样也是没用的，必须返回异步函数的promise包装 这样才对 AOP思想自定义全局异常处理函数，最先注册，try next()即可，相当于调用链条 封装错误对象状态码error codeerror messagerequest url 开发环境和生产环境的异常配置开发环境下全局的非httpError捕捉需要再抛出去，方便开发时候调试生产环境就不要抛了 一个作业题 123456789101112131415161718192021222324class A &#123; constructor() &#123; this.nameA = 'a' this.nameD = 'd' &#125; validateA() &#123; console.log(\"A\") &#125;&#125;class B extends A &#123; constructor() &#123; super() this.nameB = 'b' &#125; validateB() &#123; console.log(\"B\") &#125;&#125;var b = new B()// 编写一个函数findMembers,获取b的所有带前缀的属性和方法const members = findMembers2(b, 'name', 'validate')","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://luckyjq.github.io/tags/nodejs/"},{"name":"koa2","slug":"koa2","permalink":"https://luckyjq.github.io/tags/koa2/"}]},{"title":"使用nodejs原生http开发api接口","date":"2019-06-24T04:31:41.808Z","path":"2019/06/24/nodejs/","text":"总体架构 开发环境搭建使用webstorm进行开发，新建项目，发现没有nodejs智能提示安装node智能提示 通过npm init新建项目两个好用的插件：全局安装nodemon，支持热重载项目安装cross-env，兼容操作系统 配置package.json的script选项配置中的NODE_ENV=dev，当以npm run dev启动时，process.env.NODE_ENV的值就为dev 12\"dev\": \"cross-env NODE_ENV=dev nodemon ./bin/www.js\",\"prd\": \"cross-env NODE_ENV=production nodemon ./bin/www.js\" 设计接口 响应结构设计123456789101112//成功&#123; errno: 0, data: &#123;&#125;, message: ''&#125;//失败&#123; errno: -1, message: ''&#125; 通过es6的class新建响应模型 12345678910111213141516171819202122232425262728293031323334class BaseModel &#123; constructor(data, message) &#123; if(typeof data === 'string')&#123; this.message = data data = null message = null &#125; if(data) &#123; this.data = data &#125; if(message)&#123; this.message = message &#125; &#125;&#125;class SuccessModel extends BaseModel &#123; constructor(data, message)&#123; super(data, message) this.errno = 0 &#125;&#125;class ErrorModel extends BaseModel &#123; constructor(data, message)&#123; super(data, message) this.errno = -1&#125;&#125;module.exports = &#123; SuccessModel, ErrorModel&#125; 项目结构拆分将启动服务器封装成www.js，外部传入服务器响应函数响应函数在app.js中进行定义，函数中都可以引用req，res对象对路由进行拆分，博客路由和用户路由，在app.js中进行引用app.js中引用路由对所有请求拦截处理，有对应路由返回数据否则返回404新建controller文件夹，主要用于操作数据，然后在router中引用对应controller中的方法router中调用controller方法获得数据，封装成响应model并返回数据新增配置文件，配置mysql和redis链接信息封装mysql链接工具，封装执行sql函数 对promise的一些疑惑碰到的一些小bugsql语句定义的不规范，${username}应该要加上引号 1const sql = `select username, realname from user where username=$&#123;username&#125; and password=$&#123;password&#125;` 日志系统1.访问日志2.自定义日志，包括自定义事件，错误记录等 通过流对象写日志日志的拆分，按照天等（通常用linux的定时任务crontab） sql注入的d防范使用mysql的escape函数，所有的字段先用escape转义然后dadaw${xxx}中的${xx}就不用加引号了 npm xss模块","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://luckyjq.github.io/tags/nodejs/"}]},{"title":"使用七牛云一键上传博客图片（mac）","date":"2019-06-23T16:00:00.000Z","path":"2019/06/24/使用七牛云一键上传博客图片（mac)/","text":"嘀～小姐姐秒上传到七牛云啦！ 写博客的效率又提升了！ 随便BBhexo的博客很早之前就搭建了，零零散散写过几篇文章。现在大学生活也结束了，即将步入研究生，打算好好利用这个暑假。重新拾起博客，当作一个记录的小地方。 之前我很讨厌在hexo上写博客，因为图片配置是在是太麻烦了，首先得准备好博客的照片，然后上传到某一个图传，再拿到图片地址按照特定格式插入文章。这倒也还好，关键是那些免费图床老是容易挂。。。好不容易申请了七牛云，竟然需要给空间绑定域名，测试域名只能用一个月，蛋疼。 终于。。我申请好了独立域名，通过了备案，有了足够的时间和热情。。我又回坑了。 实现原理Alfred是个什么我也没仔细研究，大概就是一个效率工具，最🐂的地方是它支持自定义脚本，然后实现自动化操作。所以我们就是要利用这个工具和七牛的开放SDK完成一个自动化操作。 当然。。有人已经写好了这个自动化脚本了项目地址：https://github.com/jiwenxing/qimage-mac 正式开干1.下载Alfred，需要使用他的收费功能，下面会给出破解版。下载地址：https://pan.baidu.com/s/1mir5F6K提取码：jj7s 2.安装七牛云的SDK工具下载地址：https://developer.qiniu.com/kodo/tools/1302/qshell下载完后解压，把qshell_darwin_amd64文件重命名为qshell并移至usr/local/bin目录下即可。后面的脚本会引用这个SDK。 3.注册七牛云账号并实名认证自己去注册。最好再准备一个独立域名，因为七牛的测试域名有效期只有一个月。 4.下载github脚本，运行qimage.alfredworkflow 修改中间的 Run Script，具体操作见下面链接。https://github.com/jiwenxing/qimage-mac/issues/16 修改Hotkey进行自动化触发快捷键设置，推荐cmd+option+v。 现在你可以试一试了，cmd+c复制一张图片到剪切板，在md文件里cmd+option+v😯 他返回了md的图片引用格式，写博客效率又提升了呢！ 当然你可能会需要一些定制化的小变化，这时候你就要稍微读一下脚本然后进行修改了。 传个小姐姐试试水！ 喂！小妹妹！你跟谁撒娇呢！","tags":[{"name":"工具","slug":"工具","permalink":"https://luckyjq.github.io/tags/工具/"},{"name":"骚操作","slug":"骚操作","permalink":"https://luckyjq.github.io/tags/骚操作/"}]},{"title":"浏览器和nodejs的事件循环机制","date":"2019-04-20T16:00:00.000Z","path":"2019/04/21/浏览器和nodejs的事件循环机制/","text":"事件循环，画个圈圈…… 浏览器的事件循环机制浏览器事件循环图（摘自《javascript忍者秘籍第二版》13章）： 宏任务微任务宏任务：从浏览器角度，代表一个离散的，独立的工作单元比如：创建主文档对象，解析HTML，执行主线（全局）js代码更改当前URL和各种事件（页面加载，网络事件，定时器等） 微任务：是更小的任务，微任务要尽可能快的，通过异步方式执行比如：DOM变化（MutationObserver），Promise回调函数由于因为async await 本身就是promise+generator的语法糖，所以await后面的也是 从面试题理解运行机制123456789101112// 写出输出setTimeout(function () &#123; console.log(1);&#125;);new Promise(function(resolve,reject)&#123; console.log(2) resolve(3)&#125;).then(function(val)&#123; console.log(val);&#125;)console.log(4); 上面的代码执行结果为：2，4，3，1我们结合上面的事件循环图来理解下输出结果 首先执行主线（全局js代码），碰到定时器代码，定时器时间为0表示尽快执行定时器是宏任务，于是把定时器任务放入宏任务队列现在宏任务队列中是（主线，定时器） 接着往下解析，开始执行promise的代码，遇到promise里的2直接输出 promise中有一个异步方法，是微任务，于是把他放到微任务队列 继续往下执行全局代码，输出4 跑完上面的流程，js主线（全局）代码执行完成，同时也是第一个宏任务执行完成了 按照事件循环图的流程，开始检查微任务队列是否有任务，有的话执行所有微任务，输出3 第一轮循环结束，更新UI主线（全局）任务从宏任务中出队 开始新的一轮事件循环，执行队首的宏任务即之前的定时器任务输出1 通过上面的例子我们也可以知道，定时器的执行时间机制：因为js单线程的本质，我们只能控制定时器何时被加入宏任务队列，而无法控制其何时执行 再看一个例子： 1234567891011121314151617181920212223242526272829303132333435363738//请写出输出内容async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; console.log('async2');&#125;console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end');/*script startasync1 startasync2promise1script endasync1 endpromise2setTimeout*/ 上面这个例题可能会有一些地方难理解，主要是async和await 12345async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125; 等价于： 123456async function async1() &#123; console.log('async1 start'); Promise.resolve(async2()).then(() =&gt; &#123; console.log('async1 end'); &#125;)&#125; nodejs的事件循环机制","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://luckyjq.github.io/tags/nodejs/"},{"name":"js","slug":"js","permalink":"https://luckyjq.github.io/tags/js/"},{"name":"基础","slug":"基础","permalink":"https://luckyjq.github.io/tags/基础/"}]},{"title":"理解typeof和instanceof","date":"2019-04-17T09:34:32.000Z","path":"2019/04/17/理解typeof和instanceof/","text":"理解typeof和instanceof，从原型开始说起 typeof判断类型存在的问题对于这两个js关键词，一直停留在很浅显的理解上。直到最近开始刷个大公司的面试题，发现这一知识点出场之高，决心总结一下。 typeof判断类型，截图来自MDN。问题出现了，当类型为Null和Array和Object时候，均返回“object”，如何区别？ 一种常用的检测方法是使用：Object.prototype.toString.call(obj) 12var arr = [12,'aaa']Object.prototype.toString.call(arr) //\"[object Array]\" 为什么要使用Object原型上的toString方法，而不是直接调用？因为Array ，function等类型作为Object的实例，都重写了toString方法 1arr.toString() //\"12,aaa\" 但是使用上面这种方法判断也存在局限性，对于任何对象，返回都是相同的。我们现在的需求是有不同构造函数比如Student，Dog等等，我们new一个实例的时候想判断这个实例是一个Dog还是一个Student，这时候就需要用到instanceof。 instanceof大法好123456789var Student = function (name,age) &#123;this.name = namethis.age = age&#125;Student.prototype.say = function()&#123;console.log(`i am $&#123;name&#125;,and i am $&#123;age&#125; years old!`)&#125;var stu = new Student('Tom', 20)stu instanceof Student //true 要理解instanceof肯定逃不过原型链，祭出原型链大图（如果还不理解原型链可以参考其他文章，要求能把下面图看懂） 关键点：首先，js中一切都是对象，函数也是对象所有的函数都有prototype和proto属性所有的对象都有proto属性Object.prototype是所有对象的根Function.prototype是所有函数的根Object和Function都是构造函数 instanceof的判断原理很简单，就是在实例的proto链条上寻找，如果有就返回true通过上面的图也可以理解几个很奇怪的instanceof判断 1234Function instanceof Function //trueObject instanceof Function //trueObject instanceof Object //trueFunction instanceof Object //true 补充这两天看书，发现自己对instanceof的使用有个地方还是不清楚 12345function Person()&#123;&#125;Person.prototype.dance = function()&#123;&#125;function Ninja()&#123;&#125;Ninja.prototype = new Person()const ninja = new Ninja() 一般的js继承写法，一开始我想的是：Ninja.prototype被改写成一个Person实例对象了所以:ninja instanceof Ninja返回false，ninja instanceof Person 返回true 但是测试返回的是两个true 到底该如何理解instanceof?检查右边的函数原型是否存在于操作符左边的对象的原型链上Ninja.prototype 是否在ninja对象的proto链上 当你实例化时候，const ninja = new Ninja()判断ninja instanceof Ninja时，就看Ninja.prototype是否在ninja实例的proto链条上而Ninja.prototype是new Person，在ninja实例的proto链条上，所以就返回true这样才是正确理解instanceof的方式","tags":[{"name":"js","slug":"js","permalink":"https://luckyjq.github.io/tags/js/"},{"name":"基础","slug":"基础","permalink":"https://luckyjq.github.io/tags/基础/"}]}]